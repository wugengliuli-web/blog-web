<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="node,React,SSR,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta name="keywords" content="node,React,SSR">
<meta property="og:type" content="article">
<meta property="og:title" content="SSR同构框架搭建笔记">
<meta property="og:url" content="https://www.yuguomin.com/2020/01/18/create-ssr-framework/index.html">
<meta property="og:site_name" content="SuperFish&#39;s Blog">
<meta property="og:description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png">
<meta property="og:updated_time" content="2020-01-21T10:16:39.041Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SSR同构框架搭建笔记">
<meta name="twitter:description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta name="twitter:image" content="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.yuguomin.com/2020/01/18/create-ssr-framework/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #3385ff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #3385ff, 0 0 5px #3385ff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #3385ff;    /*上边框颜色*/
        border-left-color: #3385ff;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <title> SSR同构框架搭建笔记 | SuperFish's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <a href="https://github.com/yuguomin/blog-web"><img style="position:absolute;top:0;left:0;border:0;z-index:1;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SuperFish's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">day day up~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.yuguomin.com/2020/01/18/create-ssr-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YGM">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://cdn.yuguomin.com/images/common/test-smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperFish's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SSR同构框架搭建笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-18T17:21:48+08:00">
                2020-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSR/" itemprop="url" rel="index">
                    <span itemprop="name">SSR</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          

          
          
          <span class="post-time">
            &nbsp; | &nbsp;
                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-o"></i>
                  </span>
                  <span class="post-meta-item-text">字数统计:</span>
                  <span class="post-count">6.8k(字)</span>
                </span>
            
              <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">26(分)</span>
            
          </span>

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            Visitors<span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间公司运营要求把一个客户端的主站页面支持<strong>SEO</strong>，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现<strong>SSR</strong>场景开发工具，并且对原本的<strong>CSR</strong>的业务代码做微量修改即可支持。本篇内容讲述整体<strong>SSR</strong>项目的架构和总结实现过程的难点及优化。</p>
<a id="more"></a>
<p>前面先说下我们公司的开发模式，在<strong>SSR</strong>开发工具之前，我们的开发工具已经支持<strong>CSR SPA</strong>和小程序开发，并且以<strong>cli</strong>工具进行串联、生成、组织构建代码实现开发者无感知。</p>
<p>就<strong>CSR SPA</strong>而言，是对业务框架中立的，可以自行配置支持<strong>React</strong>或<strong>Vue</strong>等实现；虽然是<strong>SPA</strong>，但是以单项目多模块的形式，模块可以业务场景来进行分割，这样可实现模块的独立开发和编译，实现大型项目代码之间的解耦，不过代码解耦不是完全的无相关，会把一些公共类包进行抽取打包，这样在从一个模块打开另一个模块的时候只需要加载目标模块自己的<strong>bundle</strong>，公共包可以走浏览器缓存加载。</p>
<p>好了，bb了这一会，实际上想说明，接下来开发的<strong>SSR</strong>本身不是只是为了这个项目的一次性产品，也是要实现我们开发工具的模式，框架中立，<strong>CSR SPA</strong>的代码体验，<strong>less sass</strong>样式支持，模块式开发。目前这个工具已经开发完成，投入生产使用，满足了开发的需求。</p>
<h1 id="SSR是什么"><a href="#SSR是什么" class="headerlink" title="SSR是什么"></a>SSR是什么</h1><p>在这里，简单说一下<strong>SSR</strong>是什么，以及<strong>SSR</strong>的意义。</p>
<ol>
<li><p><strong>SSR</strong>是什么？<br>常说的<strong>CSR</strong>是客户端渲染，也就是常见的手机端标准<strong>SPA</strong>，加载的是一个基本的<strong>HTML</strong>骨架结构，包含了一些容器元素，真实的内容都打包作为了一个<strong>js</strong>文件，浏览器通过加载了这个<strong>HTML</strong>文件并执行，在自行加载<strong>js</strong>文件执行，渲染出对应的页面信息。<br>而<strong>SSR</strong>就是服务端渲染，之前的服务端渲染是使用各种语言，类似<strong>PHP</strong>、<strong>JAVA</strong>等，采用混编式的模版写法，在服务端把<strong>HTML</strong>结构生成好之后返回给客户端渲染。本项目要做的服务端渲染，是基于现在比较主流的<strong>Vue</strong>和<strong>React</strong>等框架，写法上还是基于<strong>SPA</strong>的书写方式，在服务端执行打包的代码，实现服务端渲染，然后将内容返回给客户端，客户端渲染元素，并再执行一遍<strong>js</strong>接管页面交互。</p>
</li>
<li><p><strong>SSR</strong>的意义是什么？<br>按照前面需求原因，是<strong>SSR</strong>的其中一个意义，这里再进行一下简单总结：<br><strong>SSR</strong>可以加快<strong>CSR SPA</strong>的首页面加载速度，<strong>CSR SPA</strong>要先加载通常是先加载<strong>HTML</strong>文件，冉家加载整个项目的<strong>JS</strong>文件，然后再根据<strong>JS</strong>内容进行渲染页面，设置页面交互。所以首页面市场加载有时会有短暂白屏显示。而<strong>SSR</strong>项目，在用户请求拿到页面数据的时候，服务端已经执行了一次代码把页面内容返回，客户端直接拿到进行渲染，减少了一次请求。</p>
<p><strong>SSR</strong>有利于<strong>SEO</strong>的优化，大部分搜索引擎，对于<strong>SEO</strong>都是对服务端返回的<strong>HTML</strong>结构内容进行捕捉，而通常的<strong>CSR SPA</strong>直接返回的是基本骨架结构和所需<strong>js</strong>的引入路径，需要被搜索引擎拿到的东西都被打包在了<strong>js</strong>里；而通过<strong>SSR</strong>，返回包含了网页的所有内容，更利于爬取。</p>
</li>
</ol>
<h1 id="建立整体架构"><a href="#建立整体架构" class="headerlink" title="建立整体架构"></a>建立整体架构</h1><p>我们的<strong>SSR</strong>最终决定在service上分离出web层和render层，并且都采用node环境编写，它们整体的关系是这样：<br><img src="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png" style="border:none;width:80%;"></p>
<p>整套框架的大体运作流程：</p>
<ol>
<li>用户通过浏览器请求页面数据信息，发送请求到<strong>service web</strong>端；</li>
<li><strong>service web</strong>处理请求的数据如<code>cookie</code>等，并将请求的对应模块信息一起发送给<strong>service render</strong>端；</li>
<li><strong>service render</strong>接到请求后，判断路由，进行一些同构处理后，将渲染出的html字符串等信息返回给<strong>service web</strong>端；</li>
<li><strong>service web</strong>拿到数据后，根据对应模块的模版进行组合，将组合好的页面数据字符串返回给客户端进行HTML显示；</li>
<li><strong>web</strong>端显示的模块中会加载对应客户端的<strong>bundle</strong>，然后执行一遍<em>JS</em>，执行生命周期绑定附加事件，接管页面交互。</li>
</ol>
<p>为什么要把service分成两块，是想采用微服务的设计方式，在我们公司内部有一些基础服务部门提供了一些微服务中间件和基础设施，比如性能监控，服务注册，链路追踪等，分开部署的形式可以有效利用现有资源；并且这两个服务对机器性能要求不一样，<strong>service web</strong>主要处理的用户打开页面<strong>HTML</strong>获取请求的转发，以及由<strong>service render</strong>返回的数据与对应模块<strong>HTML</strong>模版的组合，而<strong>service render</strong>则要对对应模块代码执行拿到前端渲染的具体内容，以及一些同构处理，这里的操作可能会消耗大量<code>cpu</code>，对于性能吃紧的情况下，可以分开扩容。</p>
<p>看起来前面的流程也很简单，像是客户端告诉了服务端想要哪个页面的东西，服务端就把对应页面的首屏结构给返回就可以了。但实际上这其中有很多难点。</p>
<h1 id="虚拟DOM的使用"><a href="#虚拟DOM的使用" class="headerlink" title="虚拟DOM的使用"></a>虚拟DOM的使用</h1><p>虽然我们服务端用的是<strong>node</strong>，也是<em>JS</em>的代码执行环境，但是它不是浏览器，它没有<em>DOM</em>的概念，也没有一些浏览器注入的<code>API</code>，服务端最后要返回客户端一个可以渲染的<strong>HTML</strong>结构，那么面临的第一个问题就是，如何生成这样的一个字符串，这里面就是采用了虚拟<em>DOM</em>的方式，虚拟<em>DOM</em>就是一个JS对象，是真实<em>DOM</em>的映射，在<strong>React</strong>中就是通过操作虚拟<em>DOM</em>来进行对比更新和渲染。在服务端，React或者其它框架提供了对应的API，可以把虚拟<em>DOM</em>转换成<strong>HTML</strong>字符串，完成服务端渲染。</p>
<p>以<strong>React</strong>为例，<a href="https://reactjs.org/docs/react-dom-server.html#rendertostring" target="_blank" rel="noopener"><code>ReactDOMServer.renderToString</code></a>是一个典型的将虚拟<em>DOM</em>输出为字符串的方法，服务端通过类似<code>API</code>解析后，返回客户端渲染。客户端在加载<strong>HTML</strong>后，会再去请求<em>JS</em>，执行<code>ReactDOM.hydrate</code>或<code>ReactDOM.render</code>进行事件挂载。</p>
<h1 id="路由差异处理"><a href="#路由差异处理" class="headerlink" title="路由差异处理"></a>路由差异处理</h1><p>有了虚拟<em>DOM</em>的应用，我们可以通过使得一套组件代码在两端同时使用，接下来的一个问题是两端如何得知要加载的对应组件，也就是路由配置。<br>在客户端，路由的管理通常采用两种方式，<code>hashHistory</code>和<code>browserHistory</code>，对应到<code>React Router</code>分别是<a href="https://react-router.docschina.org/web/api/HashRouter" target="_blank" rel="noopener"><code>HashRouter</code></a>和<a href="https://react-router.docschina.org/web/api/BrowserRouter" target="_blank" rel="noopener"><code>BrowserRouter</code></a>组件，但是hash信息给浏览器解析的，服务器是接收不到发送的hash信息，因此<code>HashRouter</code>不可取，我们采用<code>BrowserRouter</code>。它根据<code>window.location</code>和<code>history API</code>实现页面切换，渲染对应的组件。</p>
<p>而服务端，自然是不支持这两种<em>API</em>的，它只能通过请求的路径传递出的模块信息来得知到底要加载什么，<code>React Router</code>也提供了<a href="https://react-router.docschina.org/web/api/StaticRouter" target="_blank" rel="noopener">StaticRouter</a>，它有一个<code>location</code>参数，通过传递页面路径作为这个参数的值，可以拿到对应的虚拟DOM。</p>
<p>下面是SSR中前后两端的路由实现的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端的路由代码</span></span><br><span class="line"><span class="keyword">const</span> IndexCSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/product'</span> component=&#123;Product&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;IndexCSR /</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端的路由代码</span></span><br><span class="line"><span class="keyword">const</span> IndexSSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/product'</span> component=&#123;Product&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>StaticRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const contents = ReactDom.renderToString(&lt;IndexSSR /</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>关于<strong>store</strong>的内容稍后会有，我们可以看到两端设定不同的路由处理方式，原因就在于他们匹配机制不同，最后采用各自的渲染方式达成目的。</p>
<h1 id="打包差异处理"><a href="#打包差异处理" class="headerlink" title="打包差异处理"></a>打包差异处理</h1><p>从上面这个路由配置来说，两边共用的只有组件代码，因此在配置webpack的时候，需要对两端代码分别处理，举个demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端webpack配置</span></span><br><span class="line">&#123;</span><br><span class="line">  entry: <span class="string">'./src/client/main/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">8000</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端webpack配置</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line">&#123;</span><br><span class="line">  target: <span class="string">'node'</span>, <span class="comment">// 不会打包node核心模块内容</span></span><br><span class="line">  entry: <span class="string">'./src/client/main/ssr.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public-ssr'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()], <span class="comment">// 不会打包第三方模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        emitFile: <span class="literal">false</span> <span class="comment">// 阻止文件生成</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面两端的主要区别是：</p>
<ol>
<li>两端对路由的机制不同，所以代码不同，那么入口文件也不同，设置各自的<code>entry</code>属性。</li>
<li>服务端运行的代码如果依赖了<strong>Node</strong>的核心模块或者第三方模块，不需要把这些模块的代码进行打包，因为代码最终是在<strong>node</strong>环境执行，依赖都已经安装好了，打包只会增加体积。处理这个问题的方法是，对服务端的配置添加<code>target: &#39;node&#39;</code>，由于输出环境就是<strong>node</strong>，那么<strong>node</strong>的核心模块便不会打包。第三方模块通过插件<a href="https://github.com/liady/webpack-node-externals" target="_blank" rel="noopener">webpack-node-externals</a>，这个库会扫描node_modules文件夹中的所有package名称，然后告知<strong>webpack</strong>不要打包这些模块或者他们的子模块，当然这个插件可以配置一些白名单。</li>
<li>图片等静态资源的处理，如果两边都打包出来一份的话，会生成出重复的文件，如果<code>path</code>路径相同还会发生覆盖，那么这里采取的做法是，两端最终引入的图片都是来自客户端代码，打包的时候把ssr的<strong>url-loader</strong>配置项<code>emitFile</code>设置为<code>false</code>，阻止其产生文件即可。</li>
</ol>
<h1 id="请求同构"><a href="#请求同构" class="headerlink" title="请求同构"></a>请求同构</h1><p>一般来讲，我们的业务场景页面展示的数据有一部分数据是通过业务接口返回后生成的，在<strong>CSR</strong>场景下一般是在组件的<code>componentDidMount</code>钩子中做请求，拿到数据后<code>setState</code>渲染。那么在<strong>SSR</strong>这种情况下，我们要实现<strong>SEO</strong>效果，毕竟很多页面的数据就是来自于业务结构返回，比如列表页等等，那么就需要在服务端把这些这些数据请求好后和页面结构一并返回给客户端。</p>
<p>要完成这一步，主要有两个问题：</p>
<ol>
<li>第一个是如何知道对应页面所需要做哪些请求，并保证这些请求都在服务端完成后交付；通常我们的请求是写在<code>componentDidMount</code>钩子中，服务端是执行不到这个钩子的，因为没有<em>DOM</em>可以真实挂载。</li>
<li>完成这些请求如何和客户端交接同步；在服务端把数据搞到手之后，客户端在不重复请求的情况下，渲染的时候<code>state</code>或者<code>props</code>实际上是没有这些数据的。客户端要接管页面，当然要和服务端数据保持一致。</li>
</ol>
<p>请求同构的问题，最后我们使用<strong>redux</strong>进行解决，核心思想是，服务端先获取到每个页面需要渲染的组件，组件通过定义自己的静态方法确定是否有预请求，然后创建一个store，执行对应的请求后更新store，把数据合并在<strong>HTML</strong>结构中，以全局变量的方式注入到客户端，客户端渲染只需要获取这个全局变量再加入到自己的store中即可。</p>
<p>过程是这样的，其中有不少细节处理：<br>1.分析每个页面所需要的预请求，采用<a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" target="_blank" rel="noopener">React Router Config</a>来配置路由，再结合它的<code>matchRoutes</code>方法，通过传入服务器的请求路径，找到需要渲染的组件。</p>
<p>2.为每一个需要预请求的组件设定一个静态方法，这个静态方法的作用就是派发<strong>action</strong>获取数据。这个派发的<strong>action</strong>的内容是由异步请求返回的数据，所以在这一步要处理异步<strong>action</strong>，可以用<a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>来改造<code>dispatch</code>，当请求拿到数据后更新store。并且使用<code>Promise</code>保证在生成<strong>HTML</strong>之前要拿到所有的数据。下面是服务端简单的demo：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main/store/store.ts 模块store配置文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="comment">// 定义一个公用action，用于更新store数据</span></span><br><span class="line"><span class="keyword">const</span> storeData = <span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'STORE_DATA'</span>, data</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义数据保存的Reducer</span></span><br><span class="line"><span class="keyword">const</span> dataReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'STORE_DATA'</span>:</span><br><span class="line">      <span class="keyword">return</span> action.data;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 异步请求的方法，最终会被store.dispatch调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchDataMain = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`/some/api/xxx`</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(storeData(result.data));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 抛出创建store的方法，thunkMiddleware插件来改写store.dispatch方法使其支持异步操作</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (initialData?) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(dataReducer, initialState, applyMiddleware(thunkMiddleware));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main/views/Home.tsx  两端共用</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetchDataMain &#125; <span class="keyword">from</span> <span class="string">'../store/store'</span>;</span><br><span class="line"><span class="comment">// Home组件</span></span><br><span class="line"><span class="keyword">class</span> Home <span class="keyword">extends</span> React.Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> serverFetch = fetchDataMain; <span class="comment">// 派发一个action静态方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 在这个钩子里，判断判断服务端是否请求成功做的补救，或者CSR的时候自己的渲染</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.initialData &amp;&amp; <span class="keyword">this</span>.props.initialData.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.fetchDataMain();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; initialData &#125; = <span class="keyword">this</span>.props; <span class="comment">// 取出利用content映射的props</span></span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;initialData.content&lt;<span class="regexp">/div&gt;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ store数据和props的映射</span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  initialData: state.data</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在其props上挂载了fetchDataMain这个dispatch方法，用于CSR来更新store</span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = &#123; fetchDataMain &#125;;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用connect链接store，抛出容器组件</span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(Home);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ main/</span>ssr.tsx 模块ssr入口文件</span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter, matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderReact &#125; <span class="keyword">from</span> <span class="string">'../packages/art-ssr-react'</span>; <span class="comment">// 内部package</span></span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line"><span class="comment">// SSR的入口组件，我们将props处理为请求的request参数</span></span><br><span class="line"><span class="keyword">const</span> IndexSSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url &#125; = <span class="keyword">this</span>.props.data;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt; <span class="comment">// react redux用法，使子组件都可以访问到store</span></span><br><span class="line">      &lt;StaticRouter location=&#123;url&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">        &#123; renderRoutes(routes) &#125; <span class="comment">// 渲染静态路由</span></span><br><span class="line">      &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Main</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = (props.data || &#123;&#125;).url; <span class="comment">// 拿到请求的路径信息</span></span><br><span class="line">  <span class="comment">// dataRequirements如果有请求，会是一个Promise[]</span></span><br><span class="line">  <span class="keyword">const</span> dataRequirements = routes</span><br><span class="line">    .filter(<span class="function">(<span class="params">route</span>) =&gt;</span> matchPath(url, route)) <span class="comment">// 查找匹配路由</span></span><br><span class="line">    .map(<span class="function">(<span class="params">route</span>) =&gt;</span> route.component) <span class="comment">// 查找对应组件</span></span><br><span class="line">    .filter(<span class="function">(<span class="params">comp</span>) =&gt;</span> comp.serverFetch) <span class="comment">// 确定是否有静态的serverFetch方法</span></span><br><span class="line">    .map(<span class="function">(<span class="params">comp</span>) =&gt;</span> store.dispatch(comp.serverFetch())); <span class="comment">// store.dispatch调用action</span></span><br><span class="line">  <span class="comment">// 返回一个Promise.all包裹的处理，确保所有请求执行完毕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(dataRequirements).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// renderReact中做的就是整合数据，返回给service-web端，service-web端在调整模版返回客户端</span></span><br><span class="line">    <span class="keyword">return</span> renderReact(<span class="string">'Main'</span>, IndexSSR, store);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的内容比较长，并且涵盖的知识点比较多，没有具体用过这些功能会比较难懂。但每一步的意图都很明确。大体总结一下三个文件所做的事：</p>
<ul>
<li>main/store/store.ts，<strong>main</strong>模块<strong>store</strong>配置文件，主要是管理了触发<strong>action</strong>后异步返回数据的保存方式，以及异步请求更新<code>store</code>的方式(实际上这段的API请求部分会被分离出去)。</li>
<li>main/views/Home.tsx，<strong>main</strong>模块两端共用的<strong>Home</strong>组件代码，首先声明了<code>class</code>类型组件，然后利用<code>connect</code>绑定了组件和<code>store</code>的关系，同步了<code>props</code>数据。</li>
<li>main/ssr.tsx，<strong>main</strong>模块<strong>ssr</strong>入口文件，创建了<code>store</code>，声明了入口组件，这里最终导出的模块方法，就是通过路由规则拿到对应组件，在完成需要预请求的接口请求后，整合<strong>html</strong>和<strong>store</strong>数据。</li>
</ul>
<p>3.CSR的请求补救，在上面的代码例子中，组件是共用代码，在其<code>componentDidMount</code>钩子中像正常<strong>CSR</strong>一样添加了数据请求，<strong>SSR</strong>渲染执行不到这个钩子可以放心不会重复，另外做一层判断可以使再客户端渲染的时候不用再额外执行一遍，或者在服务端渲染请求出现问题时，有一个补救措施。最终派发<strong>action</strong>，走的是同一个流程。</p>
<p>4.请求信息携带，有的预请求的接口需要<code>cookie</code>来验证用户信息，现在这个请求过程交由服务端来处理，默认是不会有浏览器的<code>cookie</code>和其它相关headers信息的，这样拿到的结果可能就不符合预期。解决这个问题也很简单，我们可以在服务端保存客户端请求的信息，在我们的架构中，<strong>service web</strong>接到请求后，会携带客户端请求信息到<strong>service render</strong>，<strong>service render</strong>也会还原浏览器信息去请求数据接口。</p>
<p>在<strong>service render</strong>服务端处理好预请求之后，会和<strong>HTML</strong>字符串一起返回给<strong>service web</strong>，<strong>service web</strong>统一进行数据模版拼接，这一步还缺少一个<em>css</em>数据，具体拼接流程在接下来<em>css</em>同构处理后一并举例。客户端再执行完自己的<strong>bundle.js</strong>后会拿回页面控制权，所以预请求请求的只是页面初始渲染需要展示的内容，类似于分页展示的列表信息，我们只需要请求第一页的内容返回给客户端数据即可，后面需要加载其它页的列表时就属于客户端自己的处理了。</p>
<h1 id="CSS同构"><a href="#CSS同构" class="headerlink" title="CSS同构"></a>CSS同构</h1><p>在完成了请求同构和<strong>HTML</strong>结构字符串的处理，并显示到浏览器后，我们可以展示出页面想要的内容。但是会出现一个页面闪动效果，原因是因为页面的<em>CSS</em>是通过加载<strong>bundle.css</strong>后进行页面样式修改的。所以和请求同构一样，我们需要在服务端把样式处理好，并且放在模版中作为内联样式，这样客户端加载页面后，在加载外链的<strong>bundle.css</strong>，也不会出现闪动问题。</p>
<p>在这里我们采用了<a href="https://github.com/kriasoft/isomorphic-style-loader" target="_blank" rel="noopener">isomorphic-style-loader</a>来处理这个问题，首先需要修改<strong>SSR</strong>的<strong>webpack</strong>配置文件，加入<em>css</em>的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSR webpack config</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">'isomorphic-style-loader'</span>,</span><br><span class="line">    <span class="string">'css-loader'</span>,</span><br><span class="line">    <span class="string">'postcss-loader'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后按照请求同构的模版，我们对代码做修改：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main/views/Home.tsx  两端共用</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetchDataMain &#125; <span class="keyword">from</span> <span class="string">'../store/store'</span>;</span><br><span class="line"><span class="comment">// 导入书写的css文件</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'../styles/home.css'</span>;</span><br><span class="line"><span class="comment">// 引入style包装器</span></span><br><span class="line"><span class="keyword">import</span> withStyles <span class="keyword">from</span> <span class="string">'isomorphic-style-loader/withStyles'</span>;</span><br><span class="line"><span class="comment">// Home组件</span></span><br><span class="line"><span class="keyword">class</span> Home <span class="keyword">extends</span> React.Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> serverFetch = fetchDataMain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.initialData &amp;&amp; <span class="keyword">this</span>.props.initialData.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.fetchDataMain();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; initialData &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;initialData.content&lt;<span class="regexp">/div&gt;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  initialData: state.data</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = &#123; fetchDataMain &#125;;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用connect链接store，然后在用style包装器修饰组件，该方法在内部执行通过context传递的insertCss方法，返回一个组件</span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(withStyles(style)(Home));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ main/</span>ssr.tsx 模块ssr入口文件</span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter, matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderReact &#125; <span class="keyword">from</span> <span class="string">'../packages/art-ssr-react'</span>; <span class="comment">// 内部package</span></span><br><span class="line"><span class="comment">// 一个传到insertCss方法的context</span></span><br><span class="line"><span class="keyword">import</span> StyleContext <span class="keyword">from</span> <span class="string">'isomorphic-style-loader/StyleContext'</span>;</span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line"><span class="comment">// css收集器</span></span><br><span class="line"><span class="keyword">const</span> css: Set&lt;<span class="built_in">string</span>&gt; = <span class="keyword">new</span> Set(); </span><br><span class="line"><span class="comment">// insertCss方法，最后通过context组件执行，将css内容添加到css收集器</span></span><br><span class="line"><span class="keyword">const</span> insertCss = <span class="function">(<span class="params">...styles</span>) =&gt;</span> styles.forEach(<span class="function">(<span class="params">style</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getCss = style._getCss();</span><br><span class="line">  <span class="keyword">return</span> css.add(getCss);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// SSR的入口组件，我们将props处理为请求的request参数</span></span><br><span class="line"><span class="keyword">const</span> IndexSSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url &#125; = <span class="keyword">this</span>.props.data;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      <span class="comment">// 通过context的形式把insertCss传递给每个组件使用</span></span><br><span class="line">      &lt;StyleContext.Provider value=&#123;&#123; insertCss &#125;&#125;&gt;</span><br><span class="line">        &lt;StaticRouter location=&#123;url&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">          &#123; renderRoutes(routes) &#125;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>StyleContext.Provider&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default function Main(props) &#123;</span></span><br><span class="line"><span class="regexp">  const url = (props.data || &#123;&#125;).url;</span></span><br><span class="line"><span class="regexp">  const dataRequirements = routes</span></span><br><span class="line"><span class="regexp">    .filter((route) =&gt; matchPath(url, route))</span></span><br><span class="line"><span class="regexp">    .map((route) =&gt; route.component)</span></span><br><span class="line"><span class="regexp">    .filter((comp) =&gt; comp.serverFetch)</span></span><br><span class="line"><span class="regexp">    .map((comp) =&gt; store.dispatch(comp.serverFetch()));</span></span><br><span class="line"><span class="regexp">  return Promise.all(dataRequirements).then(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 将css和HTML以及state数据一起整合</span></span><br><span class="line"><span class="regexp">    return renderReact('Main', IndexSSR, store, css);</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这段代码修改里，<strong>isomorphic-style-loader</strong>是做了哪些事去解决CSS同构问题？首先，<strong>webpack loader</strong>会讲导入的<em>css</em>文件转换为对象，里面有<code>getCss</code>等方法可以获取到样式信息，然后利用<strong>context</strong>机制，把收集<code>css</code>的<code>insertCss</code>方法传递给每个组件，需要的组件再通过<code>withStyles</code>传递组件<code>style</code>，以触发收集，最终<em>css</em>代码都聚集在入口文件声明的<code>css</code>收集器中，只需要对这个Set类型的值做处理<code>[...css].join(&#39;&#39;)</code>就可以拿到页面所有样式的字符串。</p>
<h1 id="模版数据合并"><a href="#模版数据合并" class="headerlink" title="模版数据合并"></a>模版数据合并</h1><p>现在数据和<code>css</code>以及页面结构内容都已经有了，我们在<strong>service render</strong>这个服务端事情基本完成，我们将这个数据返回给<strong>service web</strong>，大概是这样的一个数据结构：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  html: <span class="string">'&lt;div class="home"&gt;&lt;/div&gt;'</span>, <span class="comment">// 经过renderToString处理</span></span><br><span class="line">  css: <span class="string">'.home img&#123;width:100%;height:100%&#125;'</span>, <span class="comment">// 经过Set类型转换</span></span><br><span class="line">  state: &#123;<span class="string">"code"</span>:<span class="string">"200"</span>,<span class="string">"message"</span>:<span class="string">"success"</span>,<span class="string">"data"</span>:&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>&#125;&#125; <span class="comment">// 经过JSON序列还的store.getState()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>service web</strong>拿到上面这段数据后，会在对应页面结构做模版组合，下面是基于<strong>express</strong>，利用<strong>routing-controllers</strong>管理的服务示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> HomeController &#123;</span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'/home'</span>)</span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">'/product'</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> main(<span class="meta">@Req</span>() req: Request, <span class="meta">@Res</span>() res: Response) &#123;</span><br><span class="line">    <span class="keyword">const</span> mainService = <span class="keyword">new</span> MainService();</span><br><span class="line">    <span class="comment">// 请求service render拿到数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123; html, css, state &#125; = <span class="keyword">await</span> mainService.requestRender(req);</span><br><span class="line">    <span class="keyword">const</span> renderedHtml = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">      &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name="keywords" content="put your keyword here" /&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name="description" content="put your content here" /&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;it is title&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;style&gt;<span class="subst">$&#123;css&#125;</span>&lt;/style&gt;</span></span><br><span class="line"><span class="string">        &lt;link rel="stylesheet" type="text/css" href="http://me.dev.com:3001/public/demo/ssr/main/bundle.css"&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;script&gt;</span></span><br><span class="line"><span class="string">          window.REDUX_DATA = <span class="subst">$&#123; state &#125;</span></span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;html&#125;</span></span></span><br><span class="line"><span class="string">        &lt;script type="text/javascript" src="http://me.dev.com:3001/public/demo/ssr/main/bundle.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">      &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.send(renderedHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们将对应的<code>state</code>设置为了一个全局变量，<strong>CSR</strong>的入口文件创建<code>store</code>时就可以获取这个变量作为默认值，然后把<code>css</code>字符串渲染在了内联样式中避免页面闪动，<code>html</code>结构也渲染在了页面中完成了浏览器的显示，并且分别引入了外链样式和客户端<strong>bundle</strong>接管页面。</p>
<p>到此，一个<strong>SSR</strong>同构框架的基本流程和难点都已经解决了。另外，有几个点在我们框架里暂时还没有加入，我们对每一个模块设置对应的模版，当然这里面也可以进行配置，模版的配置主要是<code>head</code>里面的元信息标签修改，可以使用<a href="https://github.com/nfl/react-helmet" target="_blank" rel="noopener">react-helmet</a>这个库来处理，以及在将<code>state</code>注入为全局对象时需要注意防备<em>XSS</em>攻击风险。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>整个<strong>SSR</strong>同构框架流程上没有问题了，接下来是对整个架构的优化。主要的优化措施有三个点：</p>
<ol>
<li><p><strong>service render</strong>服务端开启多个子线程负载；<br>整个流程下来，我们可以发现<strong>render</strong>服务端的负载是相当大的，要处理服务端渲染，要去请求异步数据，我们利用<strong>node</strong>的<code>cluster</code>模块创建多个<code>worker</code>，主线程在接到任务的时候分配任务给相对悠闲的<code>worker</code>来处理，每一个<code>worker</code>在执行服务端渲染的时候利用<code>vm</code>结合<code>module</code>创建<strong>独立</strong>的上下文环境。</p>
</li>
<li><p>服务端渲染缓存：<br>服务端缓存分为两个部分，<strong>service web</strong>和<strong>service render</strong>；</p>
</li>
</ol>
<p><strong>service render</strong>缓存的是每个模块的最终的入口代码，可以利用<strong>bundle</strong>代码内容做单项加密为缓存的<code>key</code>，使用<strong>lru-cache</strong>做内存缓存，这样代码一旦修改缓存就会失效，这样的好处是在<code>vm</code>上快速执行到对应的模块入口方法。<br><strong>service web</strong>端采用<strong>redis</strong>缓存数据库，可以将每次组合好的模版存入其中，当下次有客户端访问过来可以快速在缓存中查看是否已经有这些数据，减少像<strong>service render</strong>端的请求。</p>
<ol start="3">
<li>多框架中立：<br>在<strong>service web</strong>服务中我们进行了页面数据的拼接，按照上面的代码我们一直使用的范例是<strong>React</strong>为基础的，实际上，我们也可以使用<strong>Vue</strong>类似支持<code>renderToString</code>方法的框架，只要配置好对应的<strong>render</strong>请求，返回数据后进行对应位置的模版拼接就可以实现多框架渲染。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前框架已经完成，对原本的客户端主站项目进行了，项目也已经上线，目前效果还是不错的。后续仍有不少可以优化的点，对于大型项目，可以使用<code>renderToNodeStream</code>的流式渲染方式，对于<strong>service web</strong>到<strong>service render</strong>的服务间请求采用<em>rpc</em>作为服务间通信的Protocol等等。</p>
<p>整体实现框架的难点都是一些细节问题，还有个更重要的就是代码设计，最后我们使用了6个包分离了整个框架的具体内容。</p>
<ul>
<li>art-compiler-ssr：处理代码的编译配置。</li>
<li>art-ssr-aggregator-node：基于<strong>axios</strong>建立<strong>service web</strong>到<strong>service render</strong>的请求处理。</li>
<li>art-ssr-render：<strong>render</strong>服务的核心代码，包括建立子线程，执行服务端渲染。</li>
<li>art-ssr-react：处理<strong>react</strong>框架服务端和库护短渲染时的方式。</li>
<li>art-ssr-vue：处理<strong>vue</strong>框架服务端和库护短渲染时的方式。</li>
<li>art-ssr-react-router：对<strong>react-router</strong>做的定制升级。</li>
</ul>
<p>参考相关文章链接：<br><a href="https://github.com/art-software/art-core" target="_blank" rel="noopener">开发框架代码</a><br><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a><br><a href="https://nodejs.org/dist/latest-v12.x/docs/api/" target="_blank" rel="noopener">node</a><br><a href="https://react-router.docschina.org/web/guides/philosophy" target="_blank" rel="noopener">react-router</a><br><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">redux</a><br>代码中使用的工具包点击都有对应链接。</p>

      
    </div>
    <div>
      
        <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        

      
    </div>

    <div>
      
        

      
    </div>
  <div>
        <p id="div-border-left-red">
      <b>本文基于<a target="_blank" title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br>
        <span>
        <b>本文地址: </b><a href="/2020/01/18/create-ssr-framework/" title="SSR同构框架搭建笔记">https://www.yuguomin.com/2020/01/18/create-ssr-framework/</a><br><b>转载请注明出处, 谢谢！</b>
        </span>
        </p>
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"><i class="fa fa-tag"> node</i></a>
          
            <a href="/tags/React/" rel="tag"><i class="fa fa-tag"> React</i></a>
          
            <a href="/tags/SSR/" rel="tag"><i class="fa fa-tag"> SSR</i></a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/14/preload-module-tool/" rel="next" title="开发日记——性能优化之预加载quicklink">
                <i class="fa fa-chevron-left"></i> 开发日记——性能优化之预加载quicklink
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到: </div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=2bee37e5c8594"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4MC8yMjQ5MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://cdn.yuguomin.com/images/common/test-smile.jpg" alt="YGM">
          <p class="site-author-name" itemprop="name">YGM</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        
<div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("08/03/2019 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSR是什么"><span class="nav-number">2.</span> <span class="nav-text">SSR是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#建立整体架构"><span class="nav-number">3.</span> <span class="nav-text">建立整体架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟DOM的使用"><span class="nav-number">4.</span> <span class="nav-text">虚拟DOM的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由差异处理"><span class="nav-number">5.</span> <span class="nav-text">路由差异处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#打包差异处理"><span class="nav-number">6.</span> <span class="nav-text">打包差异处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求同构"><span class="nav-number">7.</span> <span class="nav-text">请求同构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS同构"><span class="nav-number">8.</span> <span class="nav-text">CSS同构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模版数据合并"><span class="nav-number">9.</span> <span class="nav-text">模版数据合并</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能优化"><span class="nav-number">10.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YGM</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Super fish
</div>


        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  




  
      <script type="text/javascript">
        (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
        })(document, 'script');
    </script>
  


  
  

  

  

  

  


  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":160,"height":160,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>

<script type="text/javascript">
  if (window.screen.width > 750) {
    var canvasScript = document.createElement("script");
    canvasScript.setAttribute("type", "text/javascript");
    canvasScript.setAttribute("src", "/lib/canvas-nest/canvas-nest.min.js");
    canvasScript.setAttribute("color", '255,0,204');
    canvasScript.setAttribute("opacity", '0.5');
    canvasScript.setAttribute("zIndex", '-2');
    canvasScript.setAttribute("count", '40');
    document.body.appendChild(canvasScript);
  }
</script>

</html>
