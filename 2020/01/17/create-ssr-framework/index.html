<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="node,SSR,React,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta name="keywords" content="node,SSR,React">
<meta property="og:type" content="article">
<meta property="og:title" content="SSR同构框架搭建笔记">
<meta property="og:url" content="https://www.yuguomin.com/2020/01/17/create-ssr-framework/index.html">
<meta property="og:site_name" content="SuperFish&#39;s Blog">
<meta property="og:description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png">
<meta property="og:updated_time" content="2020-01-20T12:51:35.189Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SSR同构框架搭建笔记">
<meta name="twitter:description" content="前言前段时间公司运营要求把一个客户端的主站页面支持SEO，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现SSR场景开发工具，并且对原本的CSR的业务代码做微量修改即可支持。本篇内容讲述整体SSR项目的架构和总结实现过程的难点及优化。">
<meta name="twitter:image" content="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.yuguomin.com/2020/01/17/create-ssr-framework/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #3385ff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #3385ff, 0 0 5px #3385ff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #3385ff;    /*上边框颜色*/
        border-left-color: #3385ff;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <title> SSR同构框架搭建笔记 | SuperFish's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <a href="https://github.com/yuguomin/blog-web"><img style="position:absolute;top:0;left:0;border:0;z-index:1;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SuperFish's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">day day up~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.yuguomin.com/2020/01/17/create-ssr-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YGM">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://cdn.yuguomin.com/images/common/test-smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperFish's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                SSR同构框架搭建笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-17T17:21:48+08:00">
                2020-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SSR/" itemprop="url" rel="index">
                    <span itemprop="name">SSR</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          

          
          
          <span class="post-time">
            &nbsp; | &nbsp;
                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-o"></i>
                  </span>
                  <span class="post-meta-item-text">字数统计:</span>
                  <span class="post-count">4k(字)</span>
                </span>
            
              <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">15(分)</span>
            
          </span>

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            Visitors<span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间公司运营要求把一个客户端的主站页面支持<strong>SEO</strong>，之前一直采用我们自己的开发框架，并没有接入这方面的功能，还好给的时间充足，基于我们原本的开发模式，实现<strong>SSR</strong>场景开发工具，并且对原本的<strong>CSR</strong>的业务代码做微量修改即可支持。本篇内容讲述整体<strong>SSR</strong>项目的架构和总结实现过程的难点及优化。</p>
<a id="more"></a>
<p>前面先说下我们公司的开发模式，在<strong>SSR</strong>开发工具之前，我们的开发工具已经支持<strong>CSR SPA</strong>和小程序开发，并且以<strong>cli</strong>工具进行串联、生成、组织构建代码实现开发者无感知。</p>
<p>就<strong>CSR SPA</strong>而言，是对业务框架中立的，可以自行配置支持<strong>React</strong>或<strong>Vue</strong>等实现；虽然是<strong>SPA</strong>，但是以单项目多模块的形式，模块可以业务场景来进行分割，这样可实现模块的独立开发和编译，实现大型项目代码之间的解耦，不过代码解耦不是完全的无相关，会把一些公共类包进行抽取打包，这样在从一个模块打开另一个模块的时候只需要加载目标模块自己的<strong>bundle</strong>，公共包可以走浏览器缓存加载。</p>
<p>好了，bb了这一会，实际上想说明，接下来开发的<strong>SSR</strong>本身不是只是为了这个项目的一次性产品，也是要实现我们开发工具的模式，框架中立，<strong>CSR SPA</strong>的代码体验，<strong>less sass</strong>样式支持，模块式开发。目前这个工具已经开发完成，投入生产使用，满足了开发的需求。</p>
<h1 id="SSR是什么"><a href="#SSR是什么" class="headerlink" title="SSR是什么"></a>SSR是什么</h1><p>在这里，简单说一下<strong>SSR</strong>是什么，以及<strong>SSR</strong>的意义。</p>
<ol>
<li><p><strong>SSR</strong>是什么？<br>常说的<strong>CSR</strong>是客户端渲染，也就是常见的手机端标准<strong>SPA</strong>，加载的是一个基本的<strong>HTML</strong>骨架结构，包含了一些容器元素，真实的内容都打包作为了一个<strong>js</strong>文件，浏览器通过加载了这个<strong>HTML</strong>文件并执行，在自行加载<strong>js</strong>文件执行，渲染出对应的页面信息。<br>而<strong>SSR</strong>就是服务端渲染，之前的服务端渲染是使用各种语言，类似<strong>PHP</strong>、<strong>JAVA</strong>等，采用混编式的模版写法，在服务端把<strong>HTML</strong>结构生成好之后返回给客户端渲染。本项目要做的服务端渲染，是基于现在比较主流的<strong>Vue</strong>和<strong>React</strong>等框架，写法上还是基于<strong>SPA</strong>的书写方式，在服务端执行打包的代码，实现服务端渲染，然后将内容返回给客户端，客户端渲染元素，并再执行一遍<strong>js</strong>接管页面交互。</p>
</li>
<li><p><strong>SSR</strong>的意义是什么？<br>按照前面需求原因，是<strong>SSR</strong>的其中一个意义，这里再进行一下简单总结：<br><strong>SSR</strong>可以加快<strong>CSR SPA</strong>的首页面加载速度，<strong>CSR SPA</strong>要先加载通常是先加载<strong>HTML</strong>文件，冉家加载整个项目的<strong>JS</strong>文件，然后再根据<strong>JS</strong>内容进行渲染页面，设置页面交互。所以首页面市场加载有时会有短暂白屏显示。而<strong>SSR</strong>项目，在用户请求拿到页面数据的时候，服务端已经执行了一次代码把页面内容返回，客户端直接拿到进行渲染，减少了一次请求。</p>
<p><strong>SSR</strong>有利于<strong>SEO</strong>的优化，大部分搜索引擎，对于<strong>SEO</strong>都是对服务端返回的<strong>HTML</strong>结构内容进行捕捉，而通常的<strong>CSR SPA</strong>直接返回的是基本骨架结构和所需<strong>js</strong>的引入路径，需要被搜索引擎拿到的东西都被打包在了<strong>js</strong>里；而通过<strong>SSR</strong>，返回包含了网页的所有内容，更利于爬取。</p>
</li>
</ol>
<h1 id="建立整体架构"><a href="#建立整体架构" class="headerlink" title="建立整体架构"></a>建立整体架构</h1><p>我们的<strong>SSR</strong>最终决定在service上分离出web层和render层，并且都采用node环境编写，它们整体的关系是这样：<br><img src="https://cdn.yuguomin.com/images/create-ssr-framework/base-framework.png" style="border:none;width:80%;"></p>
<p>整套框架的大体运作流程：</p>
<ol>
<li>用户通过浏览器请求页面数据信息，发送请求到service web端；</li>
<li>service web处理请求的数据如cookie等，并将请求的对应模块信息一起发送给service render端；</li>
<li>service render接到请求后，判断路由，进行一些同构处理后，将渲染出的html字符串等信息返回给service web端；</li>
<li>service web拿到数据后，根据对应模块的模版进行组合，将组合好的页面数据字符串返回给客户端进行HTML显示；</li>
<li>web端显示的模块中会加载对应客户端的bundle，然后执行一遍js，执行生命周期绑定附加事件，接管页面交互。</li>
</ol>
<p>为什么要把service分成两块，是想采用微服务的设计方式，在我们公司内部有一些基础服务部门提供了一些微服务中间件和基础设施，比如性能监控，服务注册，链路追踪等，分开部署的形式可以有效利用现有资源；并且这两个服务对机器性能要求不一样，service web主要处理的用户打开页面HTML获取请求的转发，以及由service render返回的数据与对应模块HTML模版的组合，而service render则要对对应模块代码执行拿到前端渲染的具体内容，以及一些同构处理，这里的操作可能会消耗大量cpu，对于性能吃紧的情况下，可以分开扩容。</p>
<p>看起来前面的流程也很简单，像是客户端告诉了服务端想要哪个页面的东西，服务端就把对应页面的首屏结构给返回就可以了。但实际上这其中有很多难点。</p>
<h1 id="虚拟DOM的使用"><a href="#虚拟DOM的使用" class="headerlink" title="虚拟DOM的使用"></a>虚拟DOM的使用</h1><p>虽然我们服务端用的是node，也是JS的代码执行环境，但是它不是浏览器，它没有DOM的概念，也没有一些浏览器注入的API，服务端最后要返回客户端一个可以渲染的HTML结构，那么面临的第一个问题就是，如何生成这样的一个字符串，这里面就是采用了虚拟DOM的方式，虚拟DOM就是一个JS对象，是真实DOM的映射，在React中就是通过操作虚拟DOM来进行对比更新和渲染。在服务端，React或者其它框架提供了对应的API，可以把虚拟DOM转换成HTML字符串，完成服务端渲染。</p>
<p>以React为例，<a href="https://reactjs.org/docs/react-dom-server.html#rendertostring" target="_blank" rel="noopener"><code>ReactDOMServer.renderToString</code></a>是一个典型的将虚拟DOM输出为字符串的方法，服务端通过类似API解析后，返回客户端渲染。客户端在加载HTML后，会再去请求js，执行<code>ReactDOM.hydrate</code>或<code>ReactDOM.render</code>进行事件挂载。</p>
<h1 id="路由差异处理"><a href="#路由差异处理" class="headerlink" title="路由差异处理"></a>路由差异处理</h1><p>有了虚拟DOM的应用，我们可以通过使得一套组件代码在两端同时使用，接下来的一个问题是两端如何得知要加载的对应组件，也就是路由配置。<br>在客户端，路由的管理通常采用两种方式，<code>hashHistory</code>和<code>browserHistory</code>，对应到<code>React Router</code>分别是<a href="https://react-router.docschina.org/web/api/HashRouter" target="_blank" rel="noopener"><code>HashRouter</code></a>和<a href="https://react-router.docschina.org/web/api/BrowserRouter" target="_blank" rel="noopener"><code>BrowserRouter</code></a>组件，但是hash信息给浏览器解析的，服务器是接收不到发送的hash信息，因此<code>HashRouter</code>不可取，我们采用<code>BrowserRouter</code>。它根据<code>window.location</code>和<code>history API</code>实现页面切换，渲染对应的组件。</p>
<p>而服务端，自然是不支持这两种API的，它只能通过请求的路径传递出的模块信息来得知到底要加载什么，<code>React Router</code>也提供了<a href="https://react-router.docschina.org/web/api/StaticRouter" target="_blank" rel="noopener">StaticRouter</a>，它有一个<code>location</code>参数，通过传递页面路径作为这个参数的值，可以拿到对应的虚拟DOM。</p>
<p>下面是SSR中前后两端的路由实现的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端的路由代码</span></span><br><span class="line"><span class="keyword">const</span> IndexCSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/product'</span> component=&#123;Product&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;IndexCSR /</span>&gt;, <span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端的路由代码</span></span><br><span class="line"><span class="keyword">const</span> IndexSSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/'</span> component=&#123;Home&#125;&gt;</span><br><span class="line">          &lt;Route path=<span class="string">'/product'</span> component=&#123;Product&#125;&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>StaticRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const contents = ReactDom.renderToString(&lt;IndexSSR /</span>&gt;);</span><br></pre></td></tr></table></figure>

<p>关于store的内容稍后会有，我们可以看到两端设定不同的路由处理方式，原因就在于他们匹配机制不同，最后采用各自的渲染方式达成目的。</p>
<h1 id="打包差异处理"><a href="#打包差异处理" class="headerlink" title="打包差异处理"></a>打包差异处理</h1><p>从上面这个路由配置来说，两边共用的只有组件代码，因此在配置webpack的时候，需要对两端代码分别处理，举个demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端webpack配置</span></span><br><span class="line">&#123;</span><br><span class="line">  entry: <span class="string">'./src/client/main/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">8000</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端webpack配置</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line">&#123;</span><br><span class="line">  target: <span class="string">'node'</span>, <span class="comment">// 不会打包node核心模块内容</span></span><br><span class="line">  entry: <span class="string">'./src/client/main/ssr.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public-ssr'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()], <span class="comment">// 不会打包第三方模块</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpeg|jpg|gif|svg)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        emitFile: <span class="literal">false</span> <span class="comment">// 阻止文件生成</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面两端的主要区别是：</p>
<ol>
<li>两端对路由的机制不同，所以代码不同，那么入口文件也不同，设置各自的<code>entry</code>属性。</li>
<li>服务端运行的代码如果依赖了Node的核心模块或者第三方模块，不需要把这些模块的代码进行打包，因为代码最终是在node环境执行，依赖都已经安装好了，打包只会增加体积。处理这个问题的方法是，对服务端的配置添加<code>target: &#39;node&#39;</code>，由于输出环境就是node，那么node的核心模块便不会打包。第三方模块通过插件<a href="https://github.com/liady/webpack-node-externals" target="_blank" rel="noopener">webpack-node-externals</a>，这个库会扫描node_modules文件夹中的所有package名称，然后告知webpack不要打包这些模块或者他们的子模块，当然这个插件可以配置一些白名单。</li>
<li>图片等静态资源的处理，如果两边都打包出来一份的话，会生成出重复的文件，如果path路径相同还会发生覆盖，那么这里采取的做法是，两端最终引入的图片都是来自客户端代码，打包的时候把ssr的url-loader配置项<code>emitFile</code>设置为false，阻止其产生文件即可。</li>
</ol>
<h1 id="请求同构"><a href="#请求同构" class="headerlink" title="请求同构"></a>请求同构</h1><p>一般来讲，我们的业务场景页面展示的数据有一部分数据是通过业务接口返回后生成的，在CSR场景下一般是在组件的componentDidMount钩子中做请求，拿到数据后setState渲染。那么在SSR这种情况下，我们要实现SEO效果，毕竟很多页面的数据就是来自于业务结构返回，比如列表页等等，那么就需要在服务端把这些这些数据请求好后和页面结构一并返回给客户端。</p>
<p>要完成这一步，主要有两个问题：</p>
<ol>
<li>第一个是如何知道对应页面所需要做哪些请求，并保证这些请求都在服务端完成后交付；通常我们的请求是写在componentDidMount钩子中，服务端是执行不到这个钩子的，因为没有DOM可以真实挂载。</li>
<li>完成这些请求如何和客户端交接同步；在服务端把数据搞到手之后，客户端在不重复请求的情况下，渲染的时候state或者props实际上是没有这些数据的。客户端要接管页面，当然要和服务端数据保持一致。</li>
</ol>
<p>请求同构的问题，最后我们使用redux进行解决，核心思想是，服务端先获取到每个页面需要渲染的组件，组件通过定义自己的静态方法确定是否有预请求，然后创建一个store，执行对应的请求后更新store，把数据合并在HTML结构中，以全局变量的方式注入到客户端，客户端渲染只需要获取这个全局变量再加入到自己的store中即可。</p>
<p>过程是这样的，其中有不少细节处理：<br>1.分析每个页面所需要的预请求，采用<a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" target="_blank" rel="noopener">React Router Config</a>来配置路由，再结合它的matchRoutes方法，通过传入服务器的请求路径，找到需要渲染的组件。</p>
<p>2.为每一个需要预请求的组件设定一个静态方法，这个静态方法的作用就是派发action获取数据。这个派发的action的内容是由异步请求返回的数据，所以在这一步要处理异步action，可以用<a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a>来改造dispatch，当请求拿到数据后更新store。并且使用Promise保证在生成HTML之前要拿到所有的数据。下面是服务端简单的demo：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main/views/Home.tsx  两端共用</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetchDataMain &#125; <span class="keyword">from</span> <span class="string">'../store/store'</span>;</span><br><span class="line"><span class="comment">// Home组件</span></span><br><span class="line"><span class="keyword">class</span> Home <span class="keyword">extends</span> React.Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> serverFetch = fetchDataMain; <span class="comment">// 派发一个action静态方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 在这个钩子里，判断判断服务端是否请求成功做的补救，或者CSR的时候自己的渲染</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.initialData &amp;&amp; <span class="keyword">this</span>.props.initialData.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.fetchDataMain();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; initialData &#125; = <span class="keyword">this</span>.props; <span class="comment">// 取出利用content映射的props</span></span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;initialData.content&lt;<span class="regexp">/div&gt;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ store数据和props的映射</span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  initialData: state.data</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在其props上挂载了fetchDataMain这个dispatch方法，用于CSR来更新store</span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = &#123; fetchDataMain &#125;;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用connect链接store，抛出容器组件</span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, mapDispatchToProps)(Home);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ main/</span>store/store.ts 模块store配置文件</span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="comment">// 定义一个公用action，用于更新store数据</span></span><br><span class="line"><span class="keyword">const</span> storeData = <span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'STORE_DATA'</span>, data</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义数据保存的Reducer</span></span><br><span class="line"><span class="keyword">const</span> dataReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'STORE_DATA'</span>:</span><br><span class="line">      <span class="keyword">return</span> action.data;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 异步请求的方法，最终会被store.dispatch调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchDataMain = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`/some/api/xxx`</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        dispatch(storeData(result.data));</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 抛出创建store的方法，thunkMiddleware插件来改写store.dispatch方法使其支持异步操作</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (initialData?) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(dataReducer, initialState, applyMiddleware(thunkMiddleware));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main/ssr.tsx 模块ssr入口文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter, matchPath &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore();</span><br><span class="line"><span class="comment">// SSR的入口组件，我们将props处理为请求的request参数</span></span><br><span class="line"><span class="keyword">const</span> IndexSSR = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url &#125; = <span class="keyword">this</span>.props.data;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt; <span class="comment">// react redux用法，使子组件都可以访问到store</span></span><br><span class="line">      &lt;StaticRouter location=&#123;url&#125; context=&#123;&#123;&#125;&#125;&gt;</span><br><span class="line">        &#123; renderRoutes(routes) &#125; <span class="comment">// 渲染静态路由</span></span><br><span class="line">      &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Main</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> url = (props.data || &#123;&#125;).url; <span class="comment">// 拿到请求的路径信息</span></span><br><span class="line">  <span class="comment">// dataRequirements如果有请求，会是一个Promise[]</span></span><br><span class="line">  <span class="keyword">const</span> dataRequirements = routes</span><br><span class="line">    .filter(<span class="function">(<span class="params">route</span>) =&gt;</span> matchPath(url, route)) <span class="comment">// 查找匹配路由</span></span><br><span class="line">    .map(<span class="function">(<span class="params">route</span>) =&gt;</span> route.component) <span class="comment">// 查找对应组件</span></span><br><span class="line">    .filter(<span class="function">(<span class="params">comp</span>) =&gt;</span> comp.serverFetch) <span class="comment">// 确定是否有静态的serverFetch方法</span></span><br><span class="line">    .map(<span class="function">(<span class="params">comp</span>) =&gt;</span> store.dispatch(comp.serverFetch())); <span class="comment">// store.dispatch调用action</span></span><br><span class="line">  <span class="comment">// 返回一个Promise.all包裹的处理，确保所有请求执行完毕</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(dataRequirements).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// renderReact中做的就是整合数据，返回给service-web端，service-web端在调整模版返回客户端</span></span><br><span class="line">    <span class="keyword">return</span> renderReact(<span class="string">'Main'</span>, IndexSSR, store);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段代码的内容比较长，</p>

      
    </div>
    <div>
      
        <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        

      
    </div>

    <div>
      
        

      
    </div>
  <div>
        <p id="div-border-left-red">
      <b>本文基于<a target="_blank" title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br>
        <span>
        <b>本文地址: </b><a href="/2020/01/17/create-ssr-framework/" title="SSR同构框架搭建笔记">https://www.yuguomin.com/2020/01/17/create-ssr-framework/</a><br><b>转载请注明出处, 谢谢！</b>
        </span>
        </p>
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/node/" rel="tag"><i class="fa fa-tag"> node</i></a>
          
            <a href="/tags/SSR/" rel="tag"><i class="fa fa-tag"> SSR</i></a>
          
            <a href="/tags/React/" rel="tag"><i class="fa fa-tag"> React</i></a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/14/preload-module-tool/" rel="next" title="开发日记——性能优化之预加载quicklink">
                <i class="fa fa-chevron-left"></i> 开发日记——性能优化之预加载quicklink
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到: </div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=2bee37e5c8594"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4MC8yMjQ5MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://cdn.yuguomin.com/images/common/test-smile.jpg" alt="YGM">
          <p class="site-author-name" itemprop="name">YGM</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        
<div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("08/03/2019 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSR是什么"><span class="nav-number">2.</span> <span class="nav-text">SSR是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#建立整体架构"><span class="nav-number">3.</span> <span class="nav-text">建立整体架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟DOM的使用"><span class="nav-number">4.</span> <span class="nav-text">虚拟DOM的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由差异处理"><span class="nav-number">5.</span> <span class="nav-text">路由差异处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#打包差异处理"><span class="nav-number">6.</span> <span class="nav-text">打包差异处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请求同构"><span class="nav-number">7.</span> <span class="nav-text">请求同构</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YGM</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Super fish
</div>


        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  




  
      <script type="text/javascript">
        (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
        })(document, 'script');
    </script>
  


  
  

  

  

  

  


  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":160,"height":160,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>

<script type="text/javascript">
  if (window.screen.width > 750) {
    var canvasScript = document.createElement("script");
    canvasScript.setAttribute("type", "text/javascript");
    canvasScript.setAttribute("src", "/lib/canvas-nest/canvas-nest.min.js");
    canvasScript.setAttribute("color", '255,0,204');
    canvasScript.setAttribute("opacity", '0.5');
    canvasScript.setAttribute("zIndex", '-2');
    canvasScript.setAttribute("count", '40');
    document.body.appendChild(canvasScript);
  }
</script>

</html>
