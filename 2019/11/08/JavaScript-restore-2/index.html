<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="前言 本篇内容主要是重塑JavaScript的第二篇，讲述知识架构运行时的数据结构的JavaScript类型知识点。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript重塑(2)——JavaScript类型">
<meta property="og:url" content="https://www.yuguomin.com/2019/11/08/JavaScript-restore-2/index.html">
<meta property="og:site_name" content="SuperFish&#39;s Blog">
<meta property="og:description" content="前言 本篇内容主要是重塑JavaScript的第二篇，讲述知识架构运行时的数据结构的JavaScript类型知识点。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/null-type-arrow.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-64.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-nums.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-max-double.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-max-up.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/type-change-table.png">
<meta property="og:updated_time" content="2019-11-15T03:21:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript重塑(2)——JavaScript类型">
<meta name="twitter:description" content="前言 本篇内容主要是重塑JavaScript的第二篇，讲述知识架构运行时的数据结构的JavaScript类型知识点。">
<meta name="twitter:image" content="https://cdn.yuguomin.com/images/JavaScript-restore/null-type-arrow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.yuguomin.com/2019/11/08/JavaScript-restore-2/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #3385ff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #3385ff, 0 0 5px #3385ff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #3385ff;    /*上边框颜色*/
        border-left-color: #3385ff;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <title> JavaScript重塑(2)——JavaScript类型 | SuperFish's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <a href="https://github.com/yuguomin/blog-web"><img style="position:absolute;top:0;left:0;border:0;z-index:1;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SuperFish's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">day day up~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.yuguomin.com/2019/11/08/JavaScript-restore-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YGM">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://cdn.yuguomin.com/images/common/test-smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperFish's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript重塑(2)——JavaScript类型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-08T21:01:57+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript-Restore/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript Restore</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          

          
          
          <span class="post-time">
            &nbsp; | &nbsp;
                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-o"></i>
                  </span>
                  <span class="post-meta-item-text">字数统计:</span>
                  <span class="post-count">8.5k(字)</span>
                </span>
            
              <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">33(分)</span>
            
          </span>

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            Visitors<span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>本篇内容主要是重塑JavaScript的第二篇，讲述知识架构运行时的数据结构的JavaScript类型知识点。<a id="more"></a>
JavaScript语言的每一个数据结构都有自己的类型。JavaScript语言定义了七种语言类型。语言类型广泛用于变量，函数参数，表达式，函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：</li>
</ul>
<ol>
<li>Undefined；</li>
<li>Null；</li>
<li>Boolean；</li>
<li>String；</li>
<li>Number；</li>
<li>Symbol；</li>
<li>Object。</li>
</ol>
<p>本篇从运行时的角度，去看JavaScript的类型系统，从简单到复杂。</p>
<h1 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-undefined-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The Undefined type has exactly one value, called undefined. Any variable that has not been assigned a value has the value undefined.<br>
意思是：Undefined类型只有一个值，即undefined。任何没有赋值的变量都是undefined。
</p> 

<h2 id="undefined的本质"><a href="#undefined的本质" class="headerlink" title="undefined的本质"></a>undefined的本质</h2><p>undefined实际上就是就是全局对像的一个属性。它和全局声明一个变量无异，也就是说这个JavaScript的undefined是一个变量，并不是一个关键字，而这个变量的最初值就是原始数据类型<code>undefined</code>。自<code>ECMAscript5</code>标准以来全局的<code>undefined</code>是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。</p>
<h2 id="undefined的使用场景"><a href="#undefined的使用场景" class="headerlink" title="undefined的使用场景"></a>undefined的使用场景</h2><p>undefined实际上在代码中代表的是<strong>未定义的值</strong>。undefined就是想表明某个值是它的原始的状态。通常会在以下场景中出现：</p>
<ul>
<li>变量声明但是未赋值，获取该变量是undefined；</li>
<li>函数调用时，没有提供指定的参数，该参数为undefined；</li>
<li>函数没有返回值，调用结果默认返回undefined；</li>
<li>获取对象没有定义的属性时返回undefined；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fn(); <span class="comment">// undefined undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.x); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined的设计缺陷"><a href="#undefined的设计缺陷" class="headerlink" title="undefined的设计缺陷"></a>undefined的设计缺陷</h2><p>前面在undefined的本质时候也说了，undefined实际上是一个变量，并不是一个关键字。那么我们是可以对其赋值的，只是在<code>ECMAscript5</code>后对全局的undefined进行了约束，保证其不变。但是在低版本浏览器(IE9以下)还是可以被赋值的，并且在局部作用域中也是可以被赋值的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line">alert(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IE9以下 弹出 1</span></span><br><span class="line"><span class="comment">// chrome 弹出 undefined</span></span><br></pre></td></tr></table></figure>

<p>局部作用域下undefined可修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line">  alert(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line">testFn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// chrome 弹出 1</span></span><br></pre></td></tr></table></figure>

<p>那么由于这种缺陷导致undefined有无意中被篡改的可能，那么我们在想要使用这个值的时候需要一种方式确保能够拿到正确的值。所以这里推荐的方法是使用<code>void(0)</code>来代替<code>undefined</code>。</p>
<p>这里简单介绍一下<code>void</code>一元操作符，<code>void</code>通常只用于获取<code>undefined</code>的原始值，不管传给它的是任何操作数，最终执行后都会返回<code>undefined</code>。<br>有一个段子：</p>
<p id="div-border-left-green">
客官你吃啥？<br>
啊，我要一碗牛肉面，面给我多煮会少放点葱多放点辣肉给我放多一点汤给我多盛点。<br>
哦，一碗牛肉面。
</p>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">void</span>(testFn());</span><br><span class="line">alert(<span class="string">`a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出 a: 3, b: undefined</span></span><br></pre></td></tr></table></figure>

<p>因此void的这个特性可以保证我们获取到<code>undefined</code>这个原始值，通常可以进行一个方法封装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获得undefined，保证它没有被重新赋值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-null-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The Null type has exactly one value, called null.<br>
意思是：Null类型只有一个值，即null。
</p> 

<h2 id="null的本质"><a href="#null的本质" class="headerlink" title="null的本质"></a>null的本质</h2><p>null和undefined不同，它是一个关键字，不可以再被赋值。null表示变量未指向任何对象，也可以把null视作尚未创建的对象。<strong>null在内存里的表示就是，栈中的变量没有指向堆中的内存对象</strong><br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/null-type-arrow.png" style="border:none;width:80%;"><br>所以当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC(垃圾回收)会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为 null，即表示该对象已经被清空，目前无效状态。</p>
<h2 id="null的使用场景"><a href="#null的使用场景" class="headerlink" title="null的使用场景"></a>null的使用场景</h2><p>null通常被用来</p>
<ul>
<li><p>作为函数的参数，表示该函数的参数不是对象；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.toString);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'1'</span>); <span class="comment">// ƒ toString() &#123; [native code] &#125;</span></span><br><span class="line">fn(<span class="literal">null</span>); <span class="comment">// Uncaught TypeError: Cannot read property 'toString' of null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为对象原型链的终点；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个引用不再是必需的。通过分配null值，有效地清除引用，并假设对象没有引用其他代码，指定垃圾收集，确保回收内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="typeof-null"><a href="#typeof-null" class="headerlink" title="typeof null"></a>typeof null</h2><p>有关null有一个设计失误，即<code>typeof null</code>输出是<code>&#39;object&#39;</code>，而实际上null有自己的类型标准Null，并不属于Object，之所以结果会是<code>&#39;object&#39;</code>，是因为 JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为<code>0</code>会被<code>typeof</code>判断为对象类型，而<code>null</code>的二进制位恰好都是<code>0</code>，因此<code>null</code>被误判断为 Object 类型。</p>
<p>如果想获得 <strong>Null</strong> 的真实类型可以通过借助对象的<code>toString</code>方法进行比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Null]'</span>;</span><br></pre></td></tr></table></figure>

<p><code>typeof null</code>曾经被在ES6的某段时间草案让它<code>typeof</code>是<code>&#39;null&#39;</code> ，但由于时间积累，牵涉甚多只好取消。</p>
<h2 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h2><p>刚介绍了<code>undefined</code>和<code>null</code>，这两个值的意义很容易被混淆，都有点“无”的意思。大多数计算机仅有一个表示无的值，<strong>C</strong>语言的<code>NULL</code>，<strong>Java</strong>语言的<code>null</code>，<strong>Python</strong>语言的<code>None</code>，<strong>Ruby</strong>语言的<code>nil</code>。但JavaScript同时设置了两个，无端增加了复杂度。这是有一定的历史原因的：</p>
<p id="div-border-left-green">
1995年<a target="_Blank" href="https://www.yuguomin.com/2019/11/01/JavaScript-restore-1/#JavaScript%E5%8F%91%E5%B1%95%E5%8F%B2">JavaScript诞生时</a>，最初像Java一样，只设置了null作为表示"无"的值。根据C语言的传统，null被设计成可以自动转为0。<br>
但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因：<br>
1. null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示"无"的值最好不是对象。<br>
2. JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。<br>
因此，Brendan Eich又设计了一个undefined。<br>
<b>null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。</b>
</p> 

<p>这样一段历史导致了null和undefined的共存，而这两者之间如果使用非严格匹配是相等的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-boolean-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The Boolean type represents a logical entity having two values, called true and false.<br>
意思是：Boolean类型表示具有两个值的逻辑实体，分别是true和false。
</p> 

<p>Boolean类型的取值只能是<code>true</code>或者<code>false</code>，它赋予了编程语言在逻辑上表达<strong>真</strong>或<strong>假</strong>的能力。缺少了Boolean，很多逻辑都无法实现。</p>
<h2 id="Boolean对象和Boolean值的转换"><a href="#Boolean对象和Boolean值的转换" class="headerlink" title="Boolean对象和Boolean值的转换"></a>Boolean对象和Boolean值的转换</h2><p>Boolean类型比较复杂的点就是弄清楚<strong>转换时的结果</strong>，什么情况下时<code>true</code>，什么情况下时<code>false</code>。<br>在使用Boolean对象包装器（语法<code>new Boolean([value])</code>）时：</p>
<ul>
<li>当传入 的值为<code>0、-0、false、null、undefined、NaN</code>或者空字符串<code>&#39;&#39;</code>和DOM对象<code>document.all</code>（现已废弃），得到的会是值为<code>false</code>的Boolean<strong>对象</strong>。</li>
<li>任何其他的值，包括值为<code>&#39;false&#39;</code>的字符串和任何对象(包括值为<code>false</code>的Boolean对象)，得到的都会是值为<code>true</code>的Boolean<strong>对象</strong>。</li>
</ul>
<p><strong>在使用Boolean作为转换函数（语法<code>Boolean([value])</code>）以及使用<code>!</code>运算符时，与获取Boolean对象的true与false转换规则一样，但是得到的结果时<code>true</code>或者<code>false</code>的Boolean值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// Boolean &#123;false&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); <span class="comment">// Boolean &#123;false&#125;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">// Boolean &#123;false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(a)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(b)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(c)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'触发了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// 弹出 '触发了' if 的判断语句隐式转换成了Boolean值</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意基本类型中的布尔值 true 和 false 与值为 true 和 false 的 Boolean 对象弄混了</strong><br>推荐获取Boolean值的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = !!(expression);          <span class="comment">// 推荐</span></span><br></pre></td></tr></table></figure>

<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-string-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The String type is the set of all ordered sequences of zero or more 16-bit unsigned integer values (“elements”) up to a maximum length of 2^53-1 elements. The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a UTF-16 code unit value. Each element is regarded as occupying a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at index 0, the next element (if any) at index 1, and so on. The length of a String is the number of elements (i.e., 16-bit values) within it. The empty String has length zero and therefore contains no elements.<br>
意思是：
String类型是0个或多个16位无符号整数值（“元素”）的所有有序序列的集合，最大长度为2^53-1个元素。 String类型通常用于表示正在运行的ECMAScript程序中的文本数据，在这种情况下，String中的每个元素都被视为UTF-16代码单元值。每个元素被视为占据序列内的位置。这些位置用非负整数索引。第一个元素（如果有）位于索引0，下一个元素（如果有）则是索引1，依此类推。 String的长度是其中的元素数（即16位值）。空String的长度为0，因此不包含任何元素。
</p> 

<h2 id="Unicode与JavaScript"><a href="#Unicode与JavaScript" class="headerlink" title="Unicode与JavaScript"></a>Unicode与JavaScript</h2><p>String类型通常是用来表示<strong>运行中的文本数据</strong>，我们使用的是文字、数字、图形符号，但是对于计算机，它的底层是使用二进制数的方式来存储和传输数据，因此想要显示所有的字符，就需要将两者映射起来，这个时候就需要一个集合，这个集合需要将全世界所有的字符包含在一个里面，这就是字符集。对于一个字符集来说要正确编码转码一个字符需要三个关键元素：<strong>字库表、编码字符集、字符编码</strong>，这三个词汇放在一起又绕口又让人糊涂，下面简单总结一下</p>
<ol>
<li><p>字库表<br>字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。那么字库表就是一个<strong>所有可读或者可显示字符</strong>的数据库，字库表决定了<strong>整个字符集能够展现表示的所有字符的范围</strong>。其实就是<strong>字符的集合</strong>。</p>
</li>
<li><p>编码字符集<br>简称字符集，它使用一个个编码值<code>code point</code>去标识每一个字符在字库表中的位置，</p>
</li>
<li><p>字符编码<br>也叫编码方式，是编码字符集和实际存储数值之间的转换关系。</p>
</li>
</ol>
<p>举个例子：<br>以超市的储物柜为例子，<br>每一个小柜箱是字符，里面有我们想要展示的字符；<br>那么整个储物柜可以说就是字库表；<br>而每一个柜箱上都有自己的序号，这个序号就是编码值，整合到一起就是编码字符集；<br>而此时，我们自己又定制了一套表格，表格里是二进制或十六进制的数字。这种把储物柜上的数字对应到表格上的方式，就是字符编码。</p>
<p>这里有一个疑问，既然每一个柜箱都有自己的唯一编码了，为什么还要定制一套表格，再去映射到编码呢？<br>原因是因为：统一字库表的原因是为了能够涵盖世界上所有的字符，但在实际使用中，每个字符的使用频率不同，真正用的上的字符相对于字库表也是非常低的，如果把每个字符都用字库表的编码进行存储，那么就会浪费非常多的字节。因此就出现了类似于<code>UTF</code>的字符编码来应对这个问题。</p>
<p>回到正题，Unicode就是一个将全世界所有的字符包含在一起的编码字符集。而我们常见的编码方式（字符编码）有<code>UTF8、UTF16、UTF32</code>，Unicode的编号从0000开始一直到10FFFF共分为17个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane。可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难。<strong>Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。</strong></p>
<p>JavaScript语言采用的是Unicode字符集，但是它支持的编码方式是<code>UCS-2</code>，这是有一定<a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">历史原因</a>的，<code>UCS-2</code>使用2个字节表示已经有码点的字符。而如今已经没有了<code>UCS-2</code>，或者说它已经被整合进了<code>UTF-16</code>，但由于JavaScript只能处理<code>UCS-2</code>编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">ES6中加强了这个支持</a>。</p>
<h2 id="string的长度"><a href="#string的长度" class="headerlink" title="string的长度"></a>string的长度</h2><p>在了解了JavaScript的编码问题后，再来看看当我们处理String类型值的长度时，我们知道在这门语言中的最大长度是2^53-1，但这个长度并不意味着肉眼所看到的字符数。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𝌆'</span>.length;</span><br><span class="line"><span class="comment">// 输出为 2</span></span><br></pre></td></tr></table></figure>

<p>为什么会是2呢？因为<code>&#39;𝌆&#39;</code>在UTF-16中的编码是4个字节的<code>0xD834 DF06</code>，4个字节的编码不属于<code>UCS-2</code>，JavaScript不认识，只会把它看作单独的两个字符<code>U+D834</code>和<code>U+DF06</code>。而在<code>UTF-16</code>中从<code>U+D800</code>到<code>U+DFFF</code>是一个空段，即这些码点不对应任何字符。所以JavaScript会认为<code>&#39;𝌆&#39;</code>是两个空字符组成的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𝌆'</span>.charCodeAt(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出 55348</span></span><br><span class="line"><span class="string">'𝌆'</span> === <span class="string">'\ud834\udf06'</span>;</span><br><span class="line"><span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>因此，关于String类型的长度，JavaScript 字符串是把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，应该格外小心。</p>
<h2 id="string的不可改变"><a href="#string的不可改变" class="headerlink" title="string的不可改变"></a>string的不可改变</h2><p>JavaScript 中的字符串具有值类型的特征，永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码块一</span></span><br><span class="line"><span class="keyword">var</span> lang = <span class="string">'Java'</span>;</span><br><span class="line">lang[<span class="number">0</span>] = <span class="string">'S'</span>;</span><br><span class="line">lang[<span class="number">1</span>] = <span class="string">'c'</span>;</span><br><span class="line">lang[<span class="number">2</span>] = <span class="string">'r'</span>;</span><br><span class="line">lang[<span class="number">3</span>] = <span class="string">'i'</span>;</span><br><span class="line">lang[<span class="number">4</span>] = <span class="string">'p'</span>;</span><br><span class="line">lang[<span class="number">5</span>] = <span class="string">'t'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br><span class="line"><span class="comment">// 输出 'Java'</span></span><br></pre></td></tr></table></figure>

<p>但是不要被下面这一段迷惑了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码块二</span></span><br><span class="line"><span class="keyword">var</span> lang = <span class="string">'Java'</span>;</span><br><span class="line">lang = lang + <span class="string">'Script'</span></span><br><span class="line"><span class="built_in">console</span>.log(lang);</span><br><span class="line"><span class="comment">// 输出 'JavaScript'</span></span><br></pre></td></tr></table></figure>

<p>看起来，下面这一段，“改变了”字符串的值，但实际上不是，代码块一中，创建了一个变量<code>lang</code>，然后开辟一段内存，里面的内容是<code>&#39;Java&#39;</code>，后续修改<code>&#39;Java&#39;</code>的字符串内容，打印仍然不变；而代码段二，同样创建了一个变量<code>lang</code>，然后在栈中开辟一段内存，里面的内容是<code>&#39;Java&#39;</code>，但是在计算<code>lang + &#39;Script&#39;</code>时从新开辟了一个内存，保存了结果<code>&#39;JavaScript&#39;</code>，然后把<code>lang</code>指向了它。因此，<strong>字符串值是不可更改的，如果想修改值是字符串变量，只能通过重新赋值的方式</strong>。</p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-data-types-and-values" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The Number type has exactly 18437736874454810627 (that is, 2^64-2^53+3) values, representing the double-precision 64-bit format IEEE 754-2008 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 2^53-2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other.<br>
意思是：
Number类型具有18437736874454810627（即2^64-2^53 + 3）值，表示IEEE标准二进制浮点运算中指定的双精度64位格式IEEE 754-2008值，但9007199254740990（也就是说，IEEE标准的2^53-2）在ECMAScript中不一样，它表示为单个特殊的NaN(“Not-a-Number”)值。 （注意，NaN值是由程序表达式NaN产生的。）在某些实现中，外部代码可能能够检测各种Not-a-Number值之间的差异，但这种行为依赖于实现；对于ECMAScript代码，所有NaN值都无法进行区分比较。
</p> 

<h2 id="Number类型的存储"><a href="#Number类型的存储" class="headerlink" title="Number类型的存储"></a>Number类型的存储</h2><p>JavaScript中的Number类型是双精度浮点数，也就是其他语言的<code>double</code>类型。它使用<strong>64-bit</strong>浮点数来进行存储（所以JS实际上也没有整数，整数也是用浮点数进行存储的），结构图如下：<br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-64.png" style="border:none;width:70%;"><br>其中：</p>
<ul>
<li>符号位：占1位，表示正负，1为正，2为负；</li>
<li>指数位：占11位，用来表示次方数；</li>
<li>尾数位：占52位，科学计数法后的有效数字（精确度）。</li>
</ul>
<p>因此一个Number类型在内存中可以被表示为<code>s * m * 2^e</code>这样的格式。<br>以<code>0.1</code>为例，它的二进制是<code>0.0001100110011001100...</code>；<br>为了节省存储空间，在计算机中它是以科学计数法表示的，也就是<code>1.100110011001100... * 2^-4</code></p>
<h2 id="Number的数值量"><a href="#Number的数值量" class="headerlink" title="Number的数值量"></a>Number的数值量</h2><p>JavaScript中的Number类型具有<strong>18437736874454810627（即2^64−2^53 + 3）</strong>个值，这个数怎么来的呢？<br>JavaScript中的数字是64-bits的双精度浮点数，因此一共有<code>2^64</code>种数值可能，当指数位<code>e</code>全为<code>1</code>的时候，表示的要么为无穷数、要么是<code>NaN</code>，而<code>e</code>的存储位数是11位，其他的一共53位，因此不是数值的可能性是<code>2^53</code>。同时JavaScript中把<code>+∞</code>和<code>-∞</code>、<code>NaN</code>定义为数值（即后面的 +3）。所以JavaScript数值的总量为：<br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-nums.png" style="border:none;width:70%;"></p>
<h2 id="精度丢失"><a href="#精度丢失" class="headerlink" title="精度丢失"></a>精度丢失</h2><p>计算机中所有的数据都是以<strong>二进制</strong>存储的，所以在计算时计算机要把数据<strong>先转换成二进制进行计算，然后在把计算结果转换成十进制</strong>。比较出名的一个案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>;</span><br><span class="line"><span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<p>根据这个计算的过程，我们先尝试把<code>0.1</code>转换成二进制<br>计算机没有储存空间限制的情况下，<code>0.1</code>转换成二进制是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span>... <span class="comment">// 1001循环</span></span><br></pre></td></tr></table></figure>

<p>利用科学技术法尾数位是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>... <span class="comment">// 1001循环</span></span><br></pre></td></tr></table></figure>

<p>根据前面存储结构的特性，尾数位第53位及以后的数字是不能存储的。规则是：如果第<strong>53</strong>位是<code>1</code>，那么向前进<code>1</code>，如果是<code>0</code>就舍弃。<br>而<code>0.1</code>的科学计数法第53是<code>1</code>，所以得到的二进制结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>

<p>同样的道理<code>0.2</code>在转换成二进制后，得到的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>

<p>理论上，两者相加得到的二进制结果会是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.010011001100110011001100110011001100110011001100110011</span></span><br></pre></td></tr></table></figure>

<p>但是实际JS计算得到的0.1+0.2的二进制是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure>

<p>而这段二进制转换成十进制的结果是<code>0.30000000000000004</code><br>就是因为这样的存储结构导致了小数在进行算术运算时的精度丢失问题。<br>正确的解决办法是使用JavaScript提供的最小精度值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。</p>
<h2 id="Number类型的最大最小值"><a href="#Number类型的最大最小值" class="headerlink" title="Number类型的最大最小值"></a>Number类型的最大最小值</h2><p>在JS中能否表示的数字的绝对值范围是5e-324 ~ 1.7976931348623157e+308，这一点可以通过<code>Number.MAX_VALUE</code>和<code>Number.MIN_VALUE</code>来得到证实：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE</span><br><span class="line"><span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>

<p>那么这两个值怎么来的？<br>再看看存储结构，在<strong>ES规范</strong>中规定<code>e</code>也就是次方数的范围在 <strong>-1074 ~ 971</strong>；<br>而<code>m</code>最大能表示的最大数是52个1，最小能表示的是1，在我们的科学计数法中，有效数字开头通常都是1，即1.XXXX的形式，因此这个<code>1</code>不存储，可以节省一个存储位，因此尾数部分可以存储的范围是<code>1 ~ 2^(52+1)</code>。<br><strong>也就是说Number能表示的最大数字绝对值范围是 2^-1074 ~ 2^(53+971)。</strong></p>
<h2 id="Number类型的最大和最小安全整数"><a href="#Number类型的最大和最小安全整数" class="headerlink" title="Number类型的最大和最小安全整数"></a>Number类型的最大和最小安全整数</h2><p>最大最小安全数字，即在这个数范围内不会出现精度丢失（小数除外）。在JS中能够表示的最大安全整数的范围是：<strong>-9007199254740991 ~ 9007199254740991</strong>，这一点可以通过<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>证实：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER</span><br><span class="line"><span class="comment">// -9007199254740991</span></span><br></pre></td></tr></table></figure>

<p>那么是为什么呢？<br>最大安全整数<code>9007199254740991</code>对应的二进制数如图：<br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-max-double.png" style="border:none;width:80%;"><br>当<code>53</code>个尾数位存储满了之后，如果想要展示更大的值，就需要在指数位上加一，这时候尾数因为没有多余的存储空间，因此只能补<code>0</code>。<br>图中第一列是科学计数法二进制数每次加值1，第一次由于满值，加在了指数上；第二列为转换为不使用科学计数法后补<code>0</code>的二进制数；第三列为转换的对应十进制数。<br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/number-type-max-up.png" style="border:none;width:80%;"><br>如图所示，在指数位为53的情况下，最后一位尾数位为<code>0</code>的数字可以被精确表示，而最后一位尾数位为<code>1</code>的数字都不能被精确表示。也就是可以被精确表示和不能被精确表示的比例是<code>1:1</code>。<br>同理，当指数为<code>54</code>的时候，只有最后两位尾数为<code>00</code>的可以被精确表示，也就是可以被精确表示和不能被精确表示的比例是<code>1:3</code>，当有效位数达到<code>x (x&gt;52)</code>的时候，可以被精确表示和不能被精确表示的比例将是<code>1 : 2^(x-52) - 1</code>。那么Number.MAX_SAFE_INTEGER ~ Number.MAX_VALUE之间可以被精确表示的整数可以说是凤毛麟角。</p>
<p><strong>安全数本质上来说就是由于数字类型在计算机中的存储结构，在尾数位不够补零之后，只要是多余的尾数为1所对应的整数都不能被精确表示。</strong></p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types-symbol-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
The Symbol type is the set of all non-String values that may be used as the key of an Object property (6.1.7).
Each possible Symbol value is unique and immutable.
Each Symbol value immutably holds an associated value called [[Description]] that is either undefined or a String value.<br>
意思是：Symbol类型是可用作Object属性的键的所有非String值的集合。每个可能的Symbol值都是唯一且不可变的。每个Symbol值都不可变地保存一个名为[[Description]]的关联值，该值是undefined的或String值。
</p> 

<h2 id="Symbol的特点"><a href="#Symbol的特点" class="headerlink" title="Symbol的特点"></a>Symbol的特点</h2><p><code>Symbol</code>类型是<code>ES6</code>新增的一种类型，它有一下几个特点：</p>
<ol>
<li>它和<code>String、Number、Boolean、Undefined、Null</code>一样，都是原始类型，不能使用<code>new</code>命令创建。由于生成的 Symbol 是一个<strong>原始类型</strong>的值，也不可以添加属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>Symbol</code>函数创建的值是<strong>独一无二</strong>的，在创建的时候可以传递一个字符串用于描述便于区分，当参数为对象时，将调用对象的<code>toString</code>方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1; <span class="comment">// Symbol()</span></span><br><span class="line">s2; <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s2 == s3; <span class="comment">// false</span></span><br><span class="line">s2 === s3; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用两个相同的字符串作为参数创建的Symbol变量，对比仍是不相等的，可见它们创建出来是独一无二的。如果想要创建相等的Symbol变量，可以使用<code>Symbol.for</code>方法。该方法接收一个参数<code>key</code>，然后搜索有没有以该参数作为名称的 Symbol 值，如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">sym1 === sym2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>Symbol</code>作为对象的属性名时，该属性不会出现在<code>for...in</code>，<code>for...of</code>循环中，也不会被<code>Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line">obj[foo] = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj); <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol的使用场景"><a href="#Symbol的使用场景" class="headerlink" title="Symbol的使用场景"></a>Symbol的使用场景</h2><ol>
<li><code>Symbol</code>类型是<strong>独一无二</strong>的，它的引入就是为了把它作为对象的key值，以解决对象的属性污染问题。有些情况下，我们需要给对象增加一个属性，但可能就会造成属性覆盖，此时就是<code>Symbol</code>的使用场景了。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 Function 的 call 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 防止 Function.prototype.myCall 的直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在这个封装的方法中，使用唯一的<code>Symbol</code>变量作为绑定对象的方法名，保证不会覆盖对象已有的方法，并且在调用完之后删除。</p>
<ol start="2">
<li>根据<code>Symbol</code>作为对象属性<strong>不可枚举</strong>的特性，我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;  <span class="comment">// 给实例添加一个收藏品</span></span><br><span class="line">    <span class="keyword">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>对象x的size属性是一个 Symbol 值，所以<code>Object.keys(x)、Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<p><code>Symbol</code>函数上还有很多属性和方法可以使用，在之后的<code>Symbol</code>专栏在进行介绍。</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-object-type" target="_blank" rel="noopener">ECAM标准的定义</a>：</p>
<p id="div-border-left-green">
An Object is logically a collection of properties. Each property is either a data property, or an accessor property, Properties are identified using key values.<br>
意思是：Object类型在逻辑上是属性的集合，每个属性要么是数据属性，要么是访问器属性。
</p> 

<p>在 JavaScript 中，对象的定义是“属性的集合”。<strong>属性分为数据属性和访问器属性</strong>，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。Object类型也可以说是引用类型，我们常见的很多<code>Array</code>数组，<code>Function</code>函数，<code>Date</code>日期、<code>RegExp</code>正则都是特殊的Object类型，看起来它们都不是由<code>Object</code>构造的，但是它们的原型链终点都是<code>Object.prototype</code>然后是<code>null</code>。本篇主要是类型的角度看Objec类型，之后会有一篇关于Object的专题。</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>在Object类型介绍之前，介绍了JavaScript的几种原始类型，但是我们在实际操作中，会有这样的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'x'</span>;</span><br><span class="line">a.length; <span class="comment">// 输出 1</span></span><br><span class="line">a.toLocaleUpperCase(); <span class="comment">// 输出 'X'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3.1</span>;</span><br><span class="line">b.toFixed(); <span class="comment">// 输出 '3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Symbol</span>.prototype.serial = <span class="number">1</span>;</span><br><span class="line">c.serial; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，这些原始类型在代码运行中是可以调用其类型的原型属性的，再看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'x'</span>;</span><br><span class="line">str.serial = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.serial); <span class="comment">// 输出是 undefined</span></span><br></pre></td></tr></table></figure>

<p>这一段代码中为<code>str</code>这个字符串添加了一个属性，并没有报错，但是最终再去获取的时候仍然是<code>undefined</code>。<br>那么这其中发生了些什么呢？<br>其实，JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p>
<ul>
<li>Number;</li>
<li>String;</li>
<li>Boolean;</li>
<li>Symbol。</li>
</ul>
<p>它们被称作<strong>包装类型</strong>。我们必须认识到<code>3</code>与<code>newNumber(3)</code>是完全不同的值，它们一个是<code>Number</code>类型，一个是对象类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> === <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="number">3</span> === <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">'str'</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>)); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'str'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>回答刚才的问题，运算符提供了<strong>装箱</strong>操作，它会根据基础类型构造一个临时包装对象，使得我们能在基础类型上调用对应对象的方法。运行完之后，包装对象创建的对象就会被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'x'</span>;</span><br><span class="line">str.serial = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.serial); <span class="comment">// 输出是 undefined</span></span><br></pre></td></tr></table></figure>

<p>在这一段代码中，首先创造了一个原始类型字符串<code>str</code>，值为<code>&#39;x&#39;</code>，代码第二行，想要给原始类型赋值的时候，创建一个包装对象<code>new String(&#39;x&#39;)</code>，然后为其添加属性<code>serial</code>为<code>1</code>，执行完这一行代码之后，该包装对象被销毁。在第三行代码，获取该属性的时候，再次创建了一个新的包装对象，然而没有这个值。所以是<code>undefined</code>。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>由于JavaScript是一门弱类型语言，所以类型转换发生非常频繁。很多时候的转换是我们主动的强制类型转换，但更多时候是程序自动进行的隐式类型转换。大部分类型转换规则如下winter老师的准备的图表：<br><img src="https://cdn.yuguomin.com/images/JavaScript-restore/type-change-table.png" style="border:none;width:80%;"><br>较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。</p>
<h2 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h2><p>字符串到数字的转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，并且支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'30'</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0o13'</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0xFF'</span>); <span class="comment">// 255</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1e3'</span>); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-1e-2'</span>); <span class="comment">// -0.01</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>parseInt</code> 和 <code>parseFloat</code> 并不使用这个转换，所以支持的语法跟这里不尽相同。</p>
<p>在不传第二个参数情况下，parseInt <strong>只支持</strong> 16 进制前缀“0x”，而且会忽略非数字字符，也<strong>不支持科学计数法</strong>。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 <strong>parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xFF'</span>); <span class="comment">// 255</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0b111'</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e3'</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0xFF'</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0b111'</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1e3'</span>); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>因此在多数情况下，<strong>Number 是比 parseInt 和 parseFloat 更好的选择。</strong></p>
<h2 id="NumberToString"><a href="#NumberToString" class="headerlink" title="NumberToString"></a>NumberToString</h2><p>在较小的范围内，数字到字符串的转换完全是符合直觉的十进制转换结果。但是当<code>Number</code>的绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。目的是为了保证产生的字符串不会过长。</p>
<h2 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h2><p>一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的构造函数，装箱转换就是把基本类型转换为对应的对象。</p>
<p>前面在讲述<code>Object</code>类型的时候已经通过包装类型讲到过装箱、拆箱的场景。并且提到全局的<code>Symbol</code>函数无法使用<code>new</code>调用，但我们仍然可以用装箱机制得到一个<code>Symbol</code>对象。</p>
<p>利用一个函数的 call 方法来强迫产生Symbol装箱</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolObj = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;).call(<span class="built_in">Symbol</span>(<span class="string">'a'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbolObj); <span class="comment">// 'object'</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObj.constructor === <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObj <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也可以利用内置的<code>Object</code>函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolObject = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="string">'a'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbolObject); <span class="comment">// 'object'</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject.constructor === <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 <code>Object.prototype.toString</code>获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symObj = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="string">'a'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(symObj)); <span class="comment">// '[object Symbol]'</span></span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此借用 <code>Object.prototype.toString</code> 方法可以准确识别对象对应的基本类型，但要注意的是，<strong><code>call</code>本身会产生装箱操作，因此还需要配合 <code>typeof</code> 判断是基本类型还是对象类型。</strong></p>
<h2 id="拆箱转换"><a href="#拆箱转换" class="headerlink" title="拆箱转换"></a>拆箱转换</h2><p>在 JavaScript 标准中，<strong>规定</strong>了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。<br>一般拆箱会调用对像类型的<code>toString</code>和<code>valueOf</code>两个方法，若<code>valueOf</code>和<code>toString</code>都不存在，或者没有返回基本类型，则抛出<code>TypeError</code>异常；</p>
<ul>
<li><p>对象类型转换成<code>Number</code>先调用<code>valueOf</code>，然后再调用<code>toString</code>；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o * <span class="number">2</span></span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象类型转换成<code>String</code>先调用<code>toString</code>，然后再调用<code>valueOf</code>；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(o)</span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再ES6之后还允许对象通过显式指定<code>[Symbol.toPrimitive]</code>来覆盖原有的行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    valueOf : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'valueOf'</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'toString'</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'toPrimitive'</span>); <span class="keyword">return</span> <span class="string">'hello'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o + <span class="string">""</span>)</span><br><span class="line"><span class="comment">// toPrimitive</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本篇文章中，学习了 JavaScript 运行时的类型系统和类型转换，除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p>
<ul>
<li>List 和 Record： 用于描述函数传参过程；</li>
<li>Set：主要用于解释字符集等；</li>
<li>Completion Record：用于描述异常、跳出等语句执行过程；</li>
<li>Reference：用于描述对象属性访问、delete 等；</li>
<li>Property Descriptor：用于描述对象的属性；</li>
<li>Lexical Environment 和 Environment Record：用于描述变量和作用域；</li>
<li>Data Block：用于描述二进制数据。</li>
</ul>
<p>程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，需要格外重视。<br>从<code>Null</code>和<code>Undefined</code>的历史看其不同；从字符编码看字符串长度；从存储方式看<code>Number</code>类型的精确度和边界问题；从值的方法调用看运行时装箱拆箱的过程。一步步，一点点，深入理解每一个知识点的内在。而不是片面的记得。</p>
<p>参考相关文章链接：<br><a href="https://time.geekbang.org/column/article/77749" target="_blank" rel="noopener">重学前端-winter</a><br><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">Unicode与JavaScript详解-阮一峰</a><br><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码-CENALULU</a><br><a href="https://juejin.im/post/5a6fce10f265da3e261c3c71" target="_blank" rel="noopener">从0.1+0.2=0.30000000000000004再看JS中的Number类型</a><br><a href="https://juejin.im/post/5c3db8b7e51d45515817bdeb" target="_blank" rel="noopener">从标准原理出发理解 JavaScript 数值精度</a><br><a href="https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-35" target="_blank" rel="noopener">【JS 进阶】你真的掌握变量和类型了吗</a></p>

      
    </div>
    <div>
      
        <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        

      
    </div>

    <div>
      
        

      
    </div>
  <div>
        <p id="div-border-left-red">
      <b>本文基于<a target="_blank" title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br>
        <span>
        <b>本文地址: </b><a href="/2019/11/08/JavaScript-restore-2/" title="JavaScript重塑(2)——JavaScript类型">https://www.yuguomin.com/2019/11/08/JavaScript-restore-2/</a><br><b>转载请注明出处, 谢谢！</b>
        </span>
        </p>
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"> JavaScript</i></a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/02/JavaScript-restore-1/" rel="next" title="JavaScript重塑(1)——历史与大纲">
                <i class="fa fa-chevron-left"></i> JavaScript重塑(1)——历史与大纲
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/16/JavaScript-restore-3/" rel="prev" title="JavaScript重塑(3)——JS的对象模型与基于对象">
                JavaScript重塑(3)——JS的对象模型与基于对象 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到: </div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=2bee37e5c8594"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4MC8yMjQ5MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://cdn.yuguomin.com/images/common/test-smile.jpg" alt="YGM">
          <p class="site-author-name" itemprop="name">YGM</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        
<div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("08/03/2019 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Undefined"><span class="nav-number">2.</span> <span class="nav-text">Undefined</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined的本质"><span class="nav-number">2.1.</span> <span class="nav-text">undefined的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined的使用场景"><span class="nav-number">2.2.</span> <span class="nav-text">undefined的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined的设计缺陷"><span class="nav-number">2.3.</span> <span class="nav-text">undefined的设计缺陷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Null"><span class="nav-number">3.</span> <span class="nav-text">Null</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null的本质"><span class="nav-number">3.1.</span> <span class="nav-text">null的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null的使用场景"><span class="nav-number">3.2.</span> <span class="nav-text">null的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-null"><span class="nav-number">3.3.</span> <span class="nav-text">typeof null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null和undefined的区别"><span class="nav-number">3.4.</span> <span class="nav-text">null和undefined的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Boolean"><span class="nav-number">4.</span> <span class="nav-text">Boolean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Boolean对象和Boolean值的转换"><span class="nav-number">4.1.</span> <span class="nav-text">Boolean对象和Boolean值的转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">5.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode与JavaScript"><span class="nav-number">5.1.</span> <span class="nav-text">Unicode与JavaScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的长度"><span class="nav-number">5.2.</span> <span class="nav-text">string的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的不可改变"><span class="nav-number">5.3.</span> <span class="nav-text">string的不可改变</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Number"><span class="nav-number">6.</span> <span class="nav-text">Number</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Number类型的存储"><span class="nav-number">6.1.</span> <span class="nav-text">Number类型的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number的数值量"><span class="nav-number">6.2.</span> <span class="nav-text">Number的数值量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精度丢失"><span class="nav-number">6.3.</span> <span class="nav-text">精度丢失</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number类型的最大最小值"><span class="nav-number">6.4.</span> <span class="nav-text">Number类型的最大最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number类型的最大和最小安全整数"><span class="nav-number">6.5.</span> <span class="nav-text">Number类型的最大和最小安全整数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Symbol"><span class="nav-number">7.</span> <span class="nav-text">Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol的特点"><span class="nav-number">7.1.</span> <span class="nav-text">Symbol的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol的使用场景"><span class="nav-number">7.2.</span> <span class="nav-text">Symbol的使用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object"><span class="nav-number">8.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#包装类型"><span class="nav-number">8.1.</span> <span class="nav-text">包装类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型转换"><span class="nav-number">9.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#StringToNumber"><span class="nav-number">9.1.</span> <span class="nav-text">StringToNumber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NumberToString"><span class="nav-number">9.2.</span> <span class="nav-text">NumberToString</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装箱转换"><span class="nav-number">9.3.</span> <span class="nav-text">装箱转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拆箱转换"><span class="nav-number">9.4.</span> <span class="nav-text">拆箱转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YGM</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Super fish
</div>


        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  




  
      <script type="text/javascript">
        (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
        })(document, 'script');
    </script>
  


  
  

  

  

  

  


  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":160,"height":160,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>

<script type="text/javascript">
  if (window.screen.width > 750) {
    var canvasScript = document.createElement("script");
    canvasScript.setAttribute("type", "text/javascript");
    canvasScript.setAttribute("src", "/lib/canvas-nest/canvas-nest.min.js");
    canvasScript.setAttribute("color", '255,0,204');
    canvasScript.setAttribute("opacity", '0.5');
    canvasScript.setAttribute("zIndex", '-2');
    canvasScript.setAttribute("count", '40');
    document.body.appendChild(canvasScript);
  }
</script>

</html>
