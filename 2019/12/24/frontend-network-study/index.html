<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="network,TCP/IP,HTTP,HTTPS,HTTP2,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="前言 通信协议方面的知识，主要掌握的就是当我们输入一个url，浏览器是通过什么获取到当前页面的数据，这也是想要实现我们前端开发最终目标，页面渲染的第一大步。了解这部分知识，对于前后端分离开发、代码排错都有帮助。">
<meta name="keywords" content="network,TCP&#x2F;IP,HTTP,HTTPS,HTTP2">
<meta property="og:type" content="article">
<meta property="og:title" content="浅入浅出前端通信协议知识">
<meta property="og:url" content="https://www.yuguomin.com/2019/12/24/frontend-network-study/index.html">
<meta property="og:site_name" content="SuperFish&#39;s Blog">
<meta property="og:description" content="前言 通信协议方面的知识，主要掌握的就是当我们输入一个url，浏览器是通过什么获取到当前页面的数据，这也是想要实现我们前端开发最终目标，页面渲染的第一大步。了解这部分知识，对于前后端分离开发、代码排错都有帮助。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://cdn.yuguomin.com/images/frontend-network-study/HTTP-base-img.png">
<meta property="og:image" content="https://cdn.yuguomin.com/images/frontend-network-study/HTTP-structure.png">
<meta property="og:updated_time" content="2019-12-28T08:23:21.185Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅入浅出前端通信协议知识">
<meta name="twitter:description" content="前言 通信协议方面的知识，主要掌握的就是当我们输入一个url，浏览器是通过什么获取到当前页面的数据，这也是想要实现我们前端开发最终目标，页面渲染的第一大步。了解这部分知识，对于前后端分离开发、代码排错都有帮助。">
<meta name="twitter:image" content="https://cdn.yuguomin.com/images/frontend-network-study/HTTP-base-img.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.yuguomin.com/2019/12/24/frontend-network-study/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #3385ff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #3385ff, 0 0 5px #3385ff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #3385ff;    /*上边框颜色*/
        border-left-color: #3385ff;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <title> 浅入浅出前端通信协议知识 | SuperFish's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <a href="https://github.com/yuguomin/blog-web"><img style="position:absolute;top:0;left:0;border:0;z-index:1;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SuperFish's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">day day up~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.yuguomin.com/2019/12/24/frontend-network-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YGM">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://cdn.yuguomin.com/images/common/test-smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperFish's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                浅入浅出前端通信协议知识
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-24T10:36:42+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index">
                    <span itemprop="name">network</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          

          
          
          <span class="post-time">
            &nbsp; | &nbsp;
                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-o"></i>
                  </span>
                  <span class="post-meta-item-text">字数统计:</span>
                  <span class="post-count">9.3k(字)</span>
                </span>
            
              <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">33(分)</span>
            
          </span>

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            Visitors<span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>通信协议方面的知识，主要掌握的就是当我们输入一个url，浏览器是通过什么获取到当前页面的数据，这也是想要实现我们前端开发最终目标，页面渲染的第一大步。了解这部分知识，对于前后端分离开发、代码排错都有帮助。</li>
</ul>
<a id="more"></a>
<p>浏览器打开一个页面首先要做的就是<strong>DNS</strong>域名解析，然后根据<strong>URL</strong>把数据取回来，取回数据通常使用的是<strong>HTTP</strong>协议。或者在我们的页面中，与服务端产生一个交互，也可以利用<strong>HTTP</strong>协议获取我们需要的信息。关于<strong>HTTP</strong>协议是什么，以及它相关扩展的知识，接下来展开一个基于前端层面的学习。</p>
<h1 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h1><p><strong>HTTP</strong>实际上就是一种互联网协议，在要具体知道它是什么之前，我们还得认识一下计算机网络的结构分层。</p>
<table style="text-align:center">
  <tbody>
      <tr>
          <td style="text-align:center">OSI七层模型</td> 
          <td style="text-align:center">TCP/IP协议族层次 </td>
          <td style="text-align:center">功能</td> 
          <td style="text-align:center">五层协议的学习结构</td> 
    </tr>
      <tr>
          <td style="text-align:center">应用层</td>
          <td style="text-align:center" rowspan="3">应用层</td>
          <td>电子邮件、远程传输、文件传输</td>
          <td style="text-align:center" rowspan="3">应用层</td>
      </tr>
      <tr>
          <td style="text-align:center">表示层</td>
          <td style="text-align:center">数据格式化、代码转换、数据加密</td>
      </tr>
      <tr>
          <td style="text-align:center">会话层</td>
          <td>解除或建立别的节点的联系</td>
      </tr>
      <tr>
          <td style="text-align:center">传输层</td>
          <td style="text-align:center">传输层</td>
          <td>提供端对端的接口，处理端到端的通信细节</td>
          <td style="text-align:center">传输层</td>
      </tr>
      <tr>
          <td style="text-align:center">网络层</td>
          <td style="text-align:center">网络层</td>
          <td>数据在网络中分组传输，网络层处理分组在网络中的活动</td>
          <td style="text-align:center">网络层</td>
      </tr>
      <tr>
          <td style="text-align:center">数据链路层</td>
          <td style="text-align:center" rowspan="2">链路层</td>
          <td>传输有地址的帧和错误检测功能</td>
          <td style="text-align:center">数据链路层</td>
      </tr>
      <tr>
          <td style="text-align:center">物理层</td>
          <td>以二进制数据形式在物理媒体上传输数据</td>
          <td style="text-align:center">物理层</td>
      </tr>
  </tbody>
</table>

<p>上面表格中的是<strong>OSI</strong>和<strong>TCP/IP</strong>两种结构模型。</p>
<ul>
<li>OSI（Open System Interconnect），是ISO（国际标准化组织）组织在1985年研究的网络互连模型。为了更好的使网络应用更为普及，推荐所有公司使用这个规范来控制网络。它是学术上和法律上的国际标准，是完整的权威的网络参考模型。</li>
<li>TCP/IP参考模型是<strong>事实上</strong>的国际标准，即现实生活中被广泛使用的网络参考模型。究其原因可以看一下Andrew S.Tanenbaum的《计算机网络》。</li>
</ul>
<p>不同的结构模型标准只是划分不同，在实现上可能封装不同。但是实际上是一个东西。</p>
<p>这里学习的方式，采用了一种五层的体系结构，中和了它们两者的优点，即表格中的最后一列所示。越往下面的层越接近硬件，越往上的层越靠近用户。每一层都有他们自己的功能，并且都靠下一层支持，为了实现这些功能，就需要遵守共同的规则，大家遵守的规则，就是 <strong>“协议”</strong>。</p>
<p>互联网的每一层，都定义了很多协议，这些协议的总称，就叫做 <strong>“互联网协议”</strong>，它们是互联网的核心。下面按照五层结构从下往上对每一层的功能做简单介绍。</p>
<p>1.物理层<br>物理层主要规定了网络的一些电气特性，它的作用就是<strong>负责传送0和1的电信号</strong>。</p>
<p>2.数据链路层<br>数据链接层的功能就是对0和1的数据进行分组。早期的时候，每个公司都有自己的电信号分组方式，后来，“以太网”（Ethernet）协议占据了主导地位。<br>以太网规定，一组电信号构成一个数据包，叫做“帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；“数据”则是数据包的具体内容。</p>
<p>那么标头中的发送者和接受者是如何标识的？<br>以太网规定，连入网络的所有设备，都必须具有“网卡”接口。数据包最终会从一块网卡传送的到另一块网卡。二者两个网卡的地址，就叫做<strong>MAC</strong>地址，每一块网卡出厂的时候都有着独一无二的<strong>MAC</strong>地址。</p>
<p>既然每块网卡有了地址，那么如何传送？<br>以太网协议中，我们假设发送者已经知道了接受者的地址，它不是一对一的发送，而是对所在网络内所有计算机发送，然后每个计算机在进行判断，是否接收。就好像老师点人答题一样，喊出名字，同学们确定是不是自己，在决定起不起身。这种方式叫做 <strong>“广播”</strong>。</p>
<p>3.网络层<br>理论上来讲，有了唯一的地址之后，任何两个地方的网卡之间就可以产生互通了。但是，考虑到广播的传输方式范围广效率低，而且局限在发送者所在的子网络。</p>
<p>互联网本身是一个巨型网络，由很多子网络所构成，因此，为了能够达到传输目的，我们必须要通过这唯一的<strong>MAC</strong>地址找到对应的子网络。如果是同一个子网络，就采用 <strong>“广播”</strong>方式发送，否则就采用 <strong>“路由”</strong>方式发送。但是<strong>MAC</strong>地址没办法办到。</p>
<p>于是，<strong>网络层</strong>诞生，引进了一种新的地址，用于判断不同的计算机是否在一个子网络中，这套地址就叫做 <strong>“网络地址”</strong>，简称 <strong>“网址”</strong>。至此每台计算机上有了两个地址，<strong>MAC</strong>地址和<strong>网络地址</strong>，但是它们之间没有任何联系。</p>
<ul>
<li><strong>网络地址</strong>则是管理员分配的，用于确定计算机所在的子网络；</li>
<li><strong>MAC</strong>地址是绑定在网卡上的，用于传输数据包到子网络中的目标网卡。<br>两者是随机组合在一起的，并且按照逻辑会先处理<strong>网络地址</strong>。</li>
</ul>
<p>4.传输层<br>好了，通过网络层建立的网络地址，加上MAC地址以及广播传递方式，我们已经可以定位到对方的计算机建立通信了。但是同时问题也来了，我们的通信是主机间的通信，但是一台主机上可能有很多的进程应用，比如微信，浏览网页等。当一个数据包传递来的时候，如何确定到底是给哪个进程的？</p>
<p>这个时候就需要一个参数，用来区分数据包到进程的对应关系，这个参数也叫做 <strong>“端口”</strong>，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p><strong>传输层</strong>的功能就是<strong>建立“端口到端口”间的通信</strong>。网络层实际上是<strong>建立“主机到主机”间的通信</strong>。有了主机和端口的通信，我们就可以实现程序间的交流了。</p>
<p>5.应用层<br>通信建立起来，计算机可以通过网络接收到各种数据包，对于各种各样的数据解读成了一个问题，因此必须事先规定好格式。</p>
<p><strong>应用层</strong>的作用，就是用来<strong>规定应用程序的数据格式</strong>。比如，在传输层实现的各种程序之间的数据包传递，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>五层结构各自的功能基本上就是这些，<strong>HTTP</strong>就是一个应用层的互联网协议，它是基于<strong>TCP</strong>协议出现的。<strong>TCP</strong>协议是作用在传输层的协议。而<strong>TCP</strong>协议的连接，依赖于网络层的<strong>IP</strong>协议。接下来，先重点从低到高把这三个协议内容学习一遍。</p>
<h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><p>IP协议作用于网络层，网络层的目的是实现主机到主机间的通信，而这一步，需要发送者和接收者的<strong>MAC</strong>地址和<strong>网络地址</strong>，<strong>IP协议</strong>就是用来<strong>规定网络地址</strong>的协议，它所定义的地址，就被称为<strong>IP地址</strong>。</p>
<p>目前，广泛采用的是IP协议第四版，简称<strong>IPv4</strong>。这个版本规定，网络地址由<code>32</code>个二进制位组成。习惯上，我们用分成四段的十进制数表示IP地址，从<code>0.0.0.0</code>一直到<code>255.255.255.255</code>。</p>
<p>但是<strong>IP协议</strong>是如何通过<strong>IP地址</strong>判断两台计算机同属一个子网络的呢？<br>在<strong>IP地址中</strong>有一部分位数表示网络部分，一部分表示主机部分。具体的判断还需要一个参数“子网掩码”，它是表示子网络特征的一个参数，也是由<code>32</code>位二进制组成，它的网络部分全部为1，主机部分全部为<code>0</code>。如果已知网络部分是前<code>24</code>位，主机部分是后<code>8</code>位，那么子网络掩码就是<code>11111111.11111111.11111111.00000000</code>，写成十进制就是<code>255.255.255.0</code>。在判断网络的时候，就通过两台计算机的子网掩码判断是否为网络部分，然后在用IP地址进行比较。确认是否在同一个子网络。</p>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p><strong>TCP协议</strong>是传输层的协议，传输程实现两台计算机中进程的通信，并提供通用的数据传输服务，在这里主要使用两种协议。一种是<strong>UDP</strong>，一种是<strong>TCP</strong>。</p>
<p><strong>UDP（User Datagram Protocol，用户数据报协议）</strong>，是一个非连接，面向报文的协议。UDP的包非常简单，并且尽最大努力的数据传输服务（不保证数据传输的可靠性）。这里就不多做介绍了。</p>
<p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，一般称作 <strong>“三次握手”</strong>，这里也只简单的描述下，以一个客户端和服务端交互为例：</p>
<ul>
<li>第一次握手：客户端将一个带有<strong>SYN</strong>标志的数据包传递给服务端；</li>
<li>第二次握手：服务端回应一个带有<strong>SYN/ACK</strong>标志的数据包给客户端；</li>
<li>第三次握手：客户端发送带有<strong>ACK</strong>标志的数据包给服务端。</li>
</ul>
<p>这里的<strong>SYN</strong>和<strong>ACK</strong>不多做解释，理解上来讲就是一种确认机制，我把我的小秘密写在纸条上给你，但是我怕你看不懂，请你再写一份告诉我你确实知道了这个小秘密。使用这两个标志来保证双方发送信息无误。</p>
<p>至此三次握手完毕成功地建立连接，可以开始传输数据了。为啥要这么麻烦的做“三次握手”？<br>其实就是和<strong>SYN</strong>和<strong>ACK</strong>的目的一样，三次握手就是为了保证双方的发送和接收都没有问题。</p>
<ul>
<li>第一次握手，服务端可以确认客户端发送正常，自己接收正常。</li>
<li>第二次握手，客户端可以确认自己发送正常，接收正常，对方接收正常，发送正常；服务端可以确认自己接收正常，对方发送正常。</li>
<li>第三次握手，客户端可以确认自己发送正常，接收正常，对方接收正常，发送正常；服务端可以确认自己接收正常，发送正常，对方发送正常，接收正常。</li>
</ul>
<p>由此就可以确定双发的发送和接收都正常了。这里还要说一下断开一个<strong>TCP</strong>连接需要“四次挥手”：</p>
<ul>
<li>第一次挥手，客户端发送<strong>FIN</strong>，用来关闭客户端到服务器的数据传送；</li>
<li>第二次挥手，服务端返回一个<strong>ACK</strong>给客户端；</li>
<li>第三次挥手，服务端关闭与客户端的连接，发送一个<strong>FIN</strong>给客户端；</li>
<li>第四次挥手，客户端返回<strong>ACK</strong>报文确认。</li>
</ul>
<p><strong>FIN</strong>就像是一个表示自己想要关闭的讯号。<br>这里有个问题是，为什么连接只要三次，可断开需要四次？<br><strong>TCP协议</strong>是一条双向的通讯通道，任何一方都可以主动断开连接，任何一方也有可能还有没有发送完的信息。就比如两个人打电话，电话双方都可以讲话，也可以由一方来提出结束，但是对方可能也没有讲完，需要双方都确认结束，然后再挂断。在第一次和第二次挥手，相当于客户端通知服务端，我这边结束了，服务端表示我知道了。然后第三次和第四次挥手是服务端告诉客户端我这边也结束了，客户端接收到后确认双方都结束了，告诉服务端我知道了。</p>
<h1 id="HTTP协议（0-9-1-1）"><a href="#HTTP协议（0-9-1-1）" class="headerlink" title="HTTP协议（0.9-1.1）"></a>HTTP协议（0.9-1.1）</h1><p>在<strong>TCP</strong>连接建立后，就到了应用层，在这一层有多种协议规定应用程序的数据格式，对于我们最常见的就是<strong>HTTP</strong>协议。<br><img src="https://cdn.yuguomin.com/images/frontend-network-study/HTTP-base-img.png" style="border:none;width:70%;"></p>
<p><strong>HTTP(Hyper Text Transfer Protocol 超文本传输协议)</strong>，看名字就可以知道是<strong>用于传输诸如HTML的超媒体文档</strong>的应用层协议。<strong>HTTP</strong>协议是基于<strong>TCP</strong>协议出现的，在TCP的基础上，规定了<code>Request-Response</code>的模式。这个模式决定了通讯必定是由浏览器端首先发起的，默认使用<code>80</code>端口。我们以它的几个关键版本的发展来学习。</p>
<h2 id="HTTP-0-9和HTTP-1-0"><a href="#HTTP-0-9和HTTP-1-0" class="headerlink" title="HTTP/0.9和HTTP/1.0"></a>HTTP/0.9和HTTP/1.0</h2><p>最早的版本是1991年发布的0.9版本，只支持<code>GET</code>请求方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>

<p>这个命令在<strong>TCP</strong>连接建立后，客户端向服务器请求（request）网页index.html。<br>协议规定，服务器只能回应<code>HTML</code>格式的字符串，不能回应别的格式。并且具有无状态性，服务器发送完毕，就关闭TCP连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>1996年5月<strong>HTTP/1.0</strong>版本发布，它增加了很多功能。</p>
<ul>
<li>增加了指定<strong>HTTP</strong>协议版本号；</li>
<li>请求与响应支持添加头信息；</li>
<li>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输；</li>
<li>开始支持客户端通过<code>POST</code>方法向服务器提交数据，支持<code>GET</code>、<code>POST</code>、<code>HEAD</code>方法；</li>
<li>响应对象以一个响应状态行开始(协议版本 + 状态码（status code） + 状态描述)；</li>
<li>短链接，每一个请求建立一个<strong>TCP</strong>连接，请求完成后立马断开连接。这会导致连接无法复用，每次发送请求都需要建立连接完成后释放，网络利用率很低；</li>
<li>队头阻塞，下一个请求必须在前一个请求响应到达之后才能发送。如果前一个阻塞，后面的请求也会被阻塞。</li>
</ul>
<p><strong>HTTP/1.0</strong>的请求例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<p><strong>HTTP/1.0</strong>的响应例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>1997年1月，<strong>HTTP/1.1</strong>版本发布，进一步完善了<strong>HTTP</strong>协议，目前很多的互联网项目都是基于<strong>HTTP 1.1</strong>在向外提供服务。这一版本的主要功能提升是：</p>
<ol>
<li><p>长链接，引入了在<strong>HTTP/1.0</strong>中浏览器为解决短链接实现的<code>Connection</code>字段功能，目的是允许<strong>HTTP</strong>设备在事情处理结束之后仍然保持<strong>TCP</strong>连接，以便未来的<strong>HTTP</strong>请求重用现在的连接，这个功能是默认的。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭<strong>TCP</strong>连接。</p>
</li>
<li><p>管道机制，<strong>HTTP/1.0</strong>中，在一个<strong>TCP连接</strong>里需要等待上一个请求的响应返回后才可以发送下一个请求造成了<strong>队头阻塞</strong>，<strong>HTTP/1.0</strong>中可以“并行”发送多个请求给服务端，而不需要等待。但实际上服务端的响应仍然是按照顺序的，比如，客户端先请求了<code>html</code>文件然后请求了一个<code>css</code>文件，服务端接收到后，哪怕<code>css</code>文件资源已经处理完毕，仍然会先返回<code>html</code>文件再返回<code>css</code>文件，这种“解决”是阻塞把转移到了服务端。不过浏览器厂商采取了一种做法，就是同时创建多个<strong>TCP</strong>连接，对于同一个域名，大多数浏览器允许同时建立<code>6</code>个持久连接。通过这种方式，就可以并行处理多个请求了。</p>
</li>
<li><p>分块传输编码，对于一些很耗时的动态操作来说，服务器要等到完成所有操作再发送数据的效率并不高。更好的是使用“流模式”产生一块发送一块。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明<strong>回应将由数量未定的数据块组成</strong>。每个非空的数据块之前，会有一个<code>16</code>进制的数值，表示这个块的长度。最后是一个大小为<code>0</code>的块，就表示本次回应的数据发送完了。这在实体长度未知时特别有用(比如由数据库动态产生的数据)。</p>
</li>
<li><p>字节范围请求，<strong>HTTP1.1</strong>支持传送内容的一部分。比如，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。该功能通过在请求消息中引入了<code>range</code>头信息来实现，它允许只请求资源的某个部分。在响应消息中<code>Content-Range</code>头域声明了返回的这部分对象的偏移值和长度。这在处理大型文件上传下载或者因为网络原因造成中断，继续上传下载的场景下十分有用。</p>
</li>
<li><p>缓存处理，当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段<code>Cache-Control</code>来控制缓存。</p>
</li>
<li><p>请求和响应都增加<code>Host</code>头信息，因为在<strong>HTTP/1.0</strong>中默认每台服务器都有唯一的<strong>IP地址</strong>，因此，请求消息中的URL并没有传递主机名。但后来，一台物理主机上可能有多个虚拟主机，它们共享一个<strong>IP地址</strong>，因此，<code>Host</code>信息就比较重要了。</p>
</li>
<li><p>新增了一些Request method，<strong>HTTP1.1</strong>增加了<code>OPTIONS</code>、<code>PUT</code>、<code>DELETE</code>、<code>TRACE</code>、<code>CONNECT</code>方法。</p>
</li>
</ol>
<h2 id="HTTP协议格式"><a href="#HTTP协议格式" class="headerlink" title="HTTP协议格式"></a>HTTP协议格式</h2><p><strong>HTTP</strong>协议经过版本的变化，它的基本格式如下图所示：<br><img src="https://cdn.yuguomin.com/images/frontend-network-study/HTTP-structure.png" style="border:none;width:70%;"></p>
<p>我们使用<a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">curl</a>命令来请求一个服务器，查看一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">"super fish"</span> -s -v -H <span class="string">"name: ygm"</span> -- <span class="string">"https://www.baidu.com"</span></span><br></pre></td></tr></table></figure>

<p>这一段的作用就是请求<code>https://www.baidu.com/a</code>这个地址，然后加入一个请求头<code>name: ygm</code>，发送<code>&quot;super fish&quot;</code>这段数据。<br>接下来从拿到的请求报文和响应报文结果来进行介绍。</p>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>使用刚才的指令，可以拿到这样的请求报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /a HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">name: ygm</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">upload completely sent off: 10 out of 10 bytes</span><br></pre></td></tr></table></figure>

<p><strong>HTTP</strong>的请求报文由三个东西组成，请求行，请求头和请求体。</p>
<ol>
<li>请求行有三个部分，请求方法，请求路径和请求的协议及版本。如上例子的第一行。</li>
<li>请求头紧随在请求行之后，是由若干行组成，每行用冒号分隔名称和值。</li>
<li>请求体在头之后，以一个空行进行分隔，可能包含文件或者表单数据。</li>
</ol>
<p>接下来我们认识一下他们的具体作用。</p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>请求方法的作用是表示希望执行的操作类型，<strong>HTTP/1.1</strong>已经支持很多种请求方法，主要有下面几种：</p>
<table>
<thead>
<tr>
<th>请求方法名称</th>
<th>请求方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取响应头。</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面(资源)。</td>
</tr>
<tr>
<td>CONNECT</td>
<td>将服务器作为代理访问其它页面。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
</tbody></table>
<p>在实际开发中，<code>GET</code>和<code>POST</code>使用的最频繁，它们两的<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">区别</a>，这里就不多说了，在理解了浏览器的限制和<strong>HTTP协议</strong>之后自然就能分析出它们的区别。</p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>请求头实际上就是一行行键值对，它实际上也是一堆数据，在<strong>HTTP</strong>规范中，规定了一些特殊的<strong>HTTP</strong>头，我们现在就来了解一些常用的请求头。</p>
<table>
<thead>
<tr>
<th>key值</th>
<th>功能</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>通知服务端，客户端可以处理的内容类型。</td>
<td>Accept: text/html</td>
<td>客户端希望接受的数据类型是html类型。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>通知服务端，客户端可以理解的内容编码方式。</td>
<td>Accept-Encoding: gzip</td>
<td>表示采用LZ777算法，以及32位CRC校验的编码方式。</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>声明浏览器端接受的语言，用于服务器端判断多语言。</td>
<td>Accept-Language: *</td>
<td>任意语言都支持。</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>控制缓存的时效性。</td>
<td>Cache-Control: no-cache</td>
<td>服务端对应请求返回的响应内容不会在客户端缓存。</td>
</tr>
<tr>
<td>Connection</td>
<td>决定当前的事务完成后，是否会关闭网络连接。</td>
<td>Connection: keep-alive</td>
<td>网络连接就是持久，可复用的，不会关闭。</td>
</tr>
<tr>
<td>Host</td>
<td>HTTP访问的服务器域名，以及可选的TCP端口号。</td>
<td>Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></td>
<td>访问80端口的<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>上次访问记录的更改时间，如果服务器认为没有发生修改，则为304。只可以用在GET或HEAD请求中。</td>
<td>if-modified-since: Wed, 25 Dec 2019 15:25:31 GMT</td>
<td>最后修改是2019年12月25日23:25:31星期三，下次访问如果不是这个时间则200重新获取，否则读取缓存。</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>再次访问页面时，携带页面的ETag与服务端的做比较，为改变返回304。</td>
<td>If-None-Match: “5e037f6b-8c8c”</td>
<td>请求页面的ETag为”5e037f6b-8c8c”</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端的标识，包含了应用类型、操作系统、软件开发商以及版本号。</td>
<td>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36</td>
<td>系统，内核，浏览器版本······</td>
</tr>
<tr>
<td>Cookie</td>
<td>客户端存储的cookie字符串。</td>
<td>Cookie: Version: 1; Token: C9834F8382E23B;</td>
<td>传递了Version和Token两个cookie值。</td>
</tr>
<tr>
<td>Referer</td>
<td>当前页面是通过此来源页面里的链接进入的。</td>
<td>Referer: <a href="https://www.yuguomin.com">https://www.yuguomin.com</a></td>
<td>当前页面是从这个页面点击来的。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>在请求中(如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
<td>数据为默认的键值对。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表示发送的请求体大小。</td>
<td>Content-Length： 10</td>
<td>发送的请求体长度是10。</td>
</tr>
</tbody></table>
<p>常见的请求头总结也就如上了，可以对比看一下示例的请求头部分是否每一个都可以理解了，详细的请求头还去看看标准吧。</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>请求体也就是请求的数据，最终会通过http请求发送给服务端的数据，一般都是使用<code>POST</code>请求方式，但是并没有明确的要求数据必须使用什么编码方式。实际上，开发者可以自己决定请求体是什么格式，只要最终发送的http请求满足了报文的要求即可。但是，数据到了服务端，对方要能够成功解析才有意义。服务端通常是根据<code>Content-Type</code>字段来获知请求体是什么编码方式，再对主体进行解析。所以说到<code>POST</code>提交数据方式，包含了<code>Content-Type</code>和消息主体编码方式两部分。一些常见的格式有：</p>
<ol>
<li>application/x-www-form-urlencoded<br><code>form</code>标签在不设置<code>enctype</code>属性的情况下，默认就是这个数据类型。请求类似如下（省略掉了其它信息）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /a HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">name=ygm&amp;age=18</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>Content-Type</code>类型为<code>application/x-www-form-urlencoded</code>，请求体的数据以<code>key=val&amp;key=val</code>的格式进行编码。</p>
<ol start="2">
<li>multipart/form-data<br>当我们使用表单上传文件的时候，必须设置<code>form</code>标签的<code>enctype</code>等于<code>multipart/form-data</code>。该格式还会生成一个<code>boundary</code>字符串来分割请求头与请求体，具体的是以一个boundary=${boundary}来进行分割，请求类似如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /a HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=asdasbdbakjb128egdbjahsb123io</span><br><span class="line"></span><br><span class="line">--asdasbdbakjb128egdbjahsb123io</span><br><span class="line">content...</span><br><span class="line">--asdasbdbakjb128egdbjahsb123io--</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>并且使用<code>--boundary</code>来分割请求头和请求体或请求体中的多个字段结构，<code>--boundary--</code>用来结束请求体。</p>
<ol start="3">
<li>application/json<br>这个值如果作为响应头的<code>Content-Type</code>是很常见的，但实际上，作为请求头也是可以的，它表示请求体是序列化的<strong>JSON</strong>字符串。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /a HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;ygm&quot;, &quot;age&quot;: 18&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这种方式对于一些比较复杂的数据结构，或者对于一些抓包工具的数据展示有很好的效果。</p>
<ol start="4">
<li>text/xml<br>表示当前请求体是<code>xml</code>格式，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /a HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;person&gt;</span><br><span class="line">  &lt;name&gt;ygm&lt;/name&gt;</span><br><span class="line">  &lt;age&gt;18&lt;/age&gt;</span><br><span class="line">&lt;/person&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应报文按照前面使用<code>curl</code>命令发送请求得到的响应报文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 222</span><br><span class="line">Content-Type: text/html; charset=iso-8859-1</span><br><span class="line">Date: Wed, 25 Dec 2019 10:48:09 GMT</span><br><span class="line">Expires: Thu, 26 Dec 2019 10:48:09 GMT</span><br><span class="line">Location: https://www.baidu.com/search/error.html</span><br><span class="line">Server: Apache</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>HTTP</strong>的响应报文也分为三个部分，响应行，响应头，响应体。</p>
<ol>
<li>响应行：分为三个部分，协议版本，状态码和状态文本。</li>
<li>响应头紧随在响应行之后，是由若干行组成，每行用冒号分隔名称和值。</li>
<li>响应体在头之后，以一个空行进行分隔，可能是<strong>html</strong>或者<strong>Json</strong>等数据。</li>
</ol>
<p>接下来认识一下响应报文中的几个重要点。</p>
<h4 id="状态码和状态文本"><a href="#状态码和状态文本" class="headerlink" title="状态码和状态文本"></a>状态码和状态文本</h4><p>状态码是一个用来表示本次http请求响应状态的<code>3</code>位数的数字代码。常见的状态码和状态文本如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态文本</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>客户端必须继续发送请求</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td>204</td>
<td>Not Content</td>
<td>请求收到，但返回信息为空</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久重定向，被请求的资源已永久移动到新位置</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时重定向，请求的资源现在临时从不同的URI响应请求。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>客户端已经执行get，但文件未变化</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>请求不允许（由于服务器上文件或目录的权限设置导致资源不可用）</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>没有发现文件，查询或URI没有找到指定资源</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>请求行中的请求方法不允许</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long</td>
<td>请求的资源URI长度大于服务器允许的长度</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器产生内部错误</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavaliable</td>
<td>服务器过载或暂停维修</td>
</tr>
</tbody></table>
<p>总结这些状态码的特点：</p>
<ul>
<li>1XX：状态码一般被浏览器HTTP库处理掉了，用户一般不知晓，用于告知客户端，服务器接到请求，请继续。</li>
<li>2XX：成功，操作被成功接收并处理。</li>
<li>3XX：重定向，请求目标发生变化，需要客户端进一步处理。</li>
<li>4XX：客户端请求错误，请求包含语法错误或无法完成请求。</li>
<li>5XX：服务器错误，服务器在处理请求的过程中发生了错误。</li>
</ul>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>和请求头类似，在响应报文中，也有一些基础信息，以键值对表示，下面也列举一些常见的响应头：</p>
<table>
<thead>
<tr>
<th>key值</th>
<th>功能</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>缓存控制，通知客户端如何控制响应内容的缓存</td>
<td>Cache-Control: max-age=3600</td>
<td>让客户端对响应内容缓存3600秒。</td>
</tr>
<tr>
<td>Connection</td>
<td>决定当前的事务完成后，是否会关闭网络连接</td>
<td>Connection: keep-alive</td>
<td>网络连接就是持久，可复用的，不会关闭。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>内容编码方式，对应请求头Accept-Encoding</td>
<td>Content-Encoding: gzip</td>
<td>采用LZ777算法，以及32位CRC校验的编码方式。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>内容长度，有利于浏览器判断内容是否已经结束</td>
<td>Content-Length: 10</td>
<td>本次数据内容的长度是10个字符，后面的是下一个回应。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容类型</td>
<td>Content-Type: text/html</td>
<td>数据类型是html</td>
</tr>
<tr>
<td>Date</td>
<td>当前服务器的日期</td>
<td>Date: Wed, 25 Dec 2019 10:48:09 GMT</td>
<td>服务器日期是···</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的标识符，用于判断下次请求是否需要到服务端取回最新资源</td>
<td>ETag: “33a64dff89d4”</td>
<td>告知客户端当前资源的标识符是···</td>
</tr>
<tr>
<td>Expires</td>
<td>过期时间，用于判断下次请求是否需要重新到服务端获取最新资源</td>
<td>Expires: Wed, 25 Dec 2019 10:48:09 GMT</td>
<td>在这个时间之后响应过期</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>表示连接的状态，可以用来设置超时时长和最大请求数</td>
<td>Keep-Alive: timeout=5, max=1000</td>
<td>空闲连接至少打开5秒，限制连接关闭前最多1000次请求</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>当前资源最后修改的时间</td>
<td>Last-Modified: Wed, 25 Dec 2019 10:48:09 GMT</td>
<td>最后修改时间是···</td>
</tr>
<tr>
<td>Server</td>
<td>服务端软件的类型</td>
<td>Server: Apache</td>
<td>服务端软件类型是Apache</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置客户端cookie，可以存在多个</td>
<td>Set-Cookie: sessionid=38afes7a8; HttpOnly; Path=/</td>
<td>设置了会话cookie</td>
</tr>
<tr>
<td>Via</td>
<td>服务端请求链路，追踪消息转发情况</td>
<td>Via: 1.0 fred, 1.1 p.example.net</td>
<td>累积的链路信息</td>
</tr>
<tr>
<td>Location</td>
<td>指定需要将页面重新定向至的地址</td>
<td>Location: <a href="http://www.yuguomin.com">http://www.yuguomin.com</a></td>
<td>告知客户端，请求这个地址</td>
</tr>
</tbody></table>
<h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><p>响应体一般就是网页的正文内容或者Json数据，有的会在响应头中会用<code>Content-Length</code>来明确响应体的长度，便于浏览器接收，对于大数据量的正文信息，也会使用<code>chunked</code>的编码方式。</p>
<p>HTTP的整体结构就是这些，发展到1.1版本，它仍然有一些缺陷，比如1.1的管道机制，但实际上是把阻塞转移到服务端，还有明文传输、头信息臃肿。<br>为解决这些问题，出现了<strong>HTTP/2.0</strong>和<strong>HTTPS</strong>。</p>
<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>2015年，发布了<strong>HTTP/2</strong>，它是<strong>HTTP/1.1</strong>的升级版本，下面列举一下它的升级重点：</p>
<p>1.二进制分帧<br><strong>HTTP/1.1</strong>的头信息肯定是文本，数据体可以是文本，也可以是二进制。<strong>HTTP/2.0</strong>在不改变原来版本语义的情况下，新增了二进制分帧层，将所有传输的信息分割成更小的消息和帧，并对他们采取二进制格式的编码使体积更小。在<strong>HTTP1.1</strong>中的首部信息（除了请求体）会被封装到<strong>Headers frame</strong>，而请求体会被放入到<strong>DATA frame</strong>，除此之外还有八种不同类型的帧。</p>
<p>2.多路复用<br><strong>HTTP/2</strong>的传输是基于二进制帧的，同域名下所有请求都是在一个<strong>TCP</strong>连接上进行的，而连接上承载了很多双向流通的流，每一个流都有一个独一无二的标识和优先级，流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输的。然后在接收端通过帧的头信息流标识符组装成完整的数据。这样就解决了之前的“队头阻塞问题”。并且优先级越高，服务器会越早回应。</p>
<p>3.头信息压缩<br><strong>HTTP</strong>协议是无状态的，每次请求都需要带上所有的信息，其中很多信息是重复的。这样会浪费带宽也影响速度。因此，<strong>HTTP/2</strong>做了优化，采用了头信息压缩机制。一方面，采用<strong>gzip</strong>或<strong>compress</strong>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都将存入表里。并生成索引号，以后就不发送同样字段了，只发送索引号，这样就提高了速度。</p>
<p>4.服务器推送<br>服务器可以为客户端的请求做多个响应，不再是一对一。也就是说，除了原始请求的对应资源，服务端还可以推送一些客户端可能会需要的资源而不需要客户端一一请求。这样可以用服务端控制一些资源提前加载，提高响应速度。</p>
<p><strong>HTTP/2</strong>在性能优化上的提升和为之后准备更高级的功能打下了很好的基础。从一定程度上，减少了开发人员很多的工作内容。但是，<strong>HTTP</strong>协议还有一个问题，安全。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><strong>HTTP</strong>协议的安全方面的问题，主要在于它的明文传输和互联网的公开环境造成，主要涉及三个点：</p>
<ol>
<li>无法确认对端的身份，就是无法确定我要快递的东西真的是本人签收，可能存在冒充。</li>
<li>传输的数据可能会被窃听，我发出去的快递，在过程中别人可以看到里面的内容。</li>
<li>传输的数据可能被篡改，我发出的快递，在传输过程中被人更换了其中的内容。</li>
</ol>
<p>鉴于此，出现了<strong>HTTPS</strong>来解决这些问题，本篇内容对<strong>HTTPS</strong>的介绍主要只涉及到它的大概过程。<br><strong>HTTPS</strong>不是应用层的一种新协议，它是采用来<strong>SSL（SecureSocket Layer）或TLS（Transport Layer Security）</strong>协议作为通信接口的<strong>HTTP</strong>协议，这个通信接口可以用来加密，构建于<strong>TCP</strong>协议之上。他们利用对称加密的方式加密通信信息，利用非对称加密加密对称加密的密钥，再利用证书保证非对称加密的公开密钥的正确性。这样，在保持了<strong>HTTP</strong>设计思想的同时，也保证了传输的安全性，以及最大程度的节约了加密解密的性能。</p>
<h1 id="WebScoket"><a href="#WebScoket" class="headerlink" title="WebScoket"></a>WebScoket</h1><p>WebScoket协议在2011年成为了国际标准，它的目的就是<strong>实现真正的服务端客户端全双工通信</strong>，也就是服务端也可以主动发起消息了。这里介绍它的几个特点：</p>
<ol>
<li>建立在TCP协议之上；</li>
<li><strong>WebSocket</strong>是由<strong>http</strong>先发起的，端口也是80和443，握手阶段采用<strong>HTTP</strong>协议，然后再转为<strong>WebSocket</strong>连接;</li>
<li>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是<strong>URL</strong>。</li>
</ol>
<p>不同于<strong>HTTP/2.0 Server Push</strong>基于客户端发起请求后，服务端可以主动推送一些相关的资源。而是可以完全的主动发起通信。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的这些内容，是最近几天整理下来的，有的知识点如果往深了看实在是太深了…这里基于我目前的知识水平和应用角度，综合了关于互联网协议的相关知识，内容还是<strong>HTTP协议</strong>为主的，毕竟是使用最多。可能有一些理解不当的地方，还请指出。</p>
<p>总结完了这一块的知识，对日常开发的前后端交互，浏览器的数据获取有了更深刻的印象。也从这几个<strong>HTTP</strong>版本的变迁体会到一些设计方式和传输优化上的思想。学海无涯，且静看眼前发纷飞。</p>
<p>参考相关文章链接：<br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议</a><br><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/#prettyPhoto" target="_blank" rel="noopener">HTTP2.0奇妙日常</a><br><a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">HTTP/1.0</a><br><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">HTTP/1.1</a><br><a href="https://http2.github.io/http2-spec/" target="_blank" rel="noopener">HTTP/2</a><br><a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">TLS</a></p>

      
    </div>
    <div>
      
        <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        

      
    </div>

    <div>
      
        

      
    </div>
  <div>
        <p id="div-border-left-red">
      <b>本文基于<a target="_blank" title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br>
        <span>
        <b>本文地址: </b><a href="/2019/12/24/frontend-network-study/" title="浅入浅出前端通信协议知识">https://www.yuguomin.com/2019/12/24/frontend-network-study/</a><br><b>转载请注明出处, 谢谢！</b>
        </span>
        </p>
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/network/" rel="tag"><i class="fa fa-tag"> network</i></a>
          
            <a href="/tags/TCP-IP/" rel="tag"><i class="fa fa-tag"> TCP/IP</i></a>
          
            <a href="/tags/HTTP/" rel="tag"><i class="fa fa-tag"> HTTP</i></a>
          
            <a href="/tags/HTTPS/" rel="tag"><i class="fa fa-tag"> HTTPS</i></a>
          
            <a href="/tags/HTTP2/" rel="tag"><i class="fa fa-tag"> HTTP2</i></a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/19/CSS-restore-3/" rel="next" title="CSS重塑(3)——CSS布局">
                <i class="fa fa-chevron-left"></i> CSS重塑(3)——CSS布局
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/28/cross-domain-solutions/" rel="prev" title="跨域的解决方法及原理">
                跨域的解决方法及原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到: </div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=2bee37e5c8594"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4MC8yMjQ5MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://cdn.yuguomin.com/images/common/test-smile.jpg" alt="YGM">
          <p class="site-author-name" itemprop="name">YGM</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        
<div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("08/03/2019 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络结构"><span class="nav-number">2.</span> <span class="nav-text">计算机网络结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IP协议"><span class="nav-number">3.</span> <span class="nav-text">IP协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP协议"><span class="nav-number">4.</span> <span class="nav-text">TCP协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP协议（0-9-1-1）"><span class="nav-number">5.</span> <span class="nav-text">HTTP协议（0.9-1.1）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-0-9和HTTP-1-0"><span class="nav-number">5.1.</span> <span class="nav-text">HTTP/0.9和HTTP/1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-1"><span class="nav-number">5.2.</span> <span class="nav-text">HTTP/1.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP协议格式"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP协议格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求报文"><span class="nav-number">5.3.1.</span> <span class="nav-text">请求报文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求方法"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">请求方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求头"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">请求头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求体"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">请求体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应报文"><span class="nav-number">5.3.2.</span> <span class="nav-text">响应报文</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态码和状态文本"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">状态码和状态文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应头"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">响应头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应体"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">响应体</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-2"><span class="nav-number">6.</span> <span class="nav-text">HTTP/2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTPS"><span class="nav-number">7.</span> <span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebScoket"><span class="nav-number">8.</span> <span class="nav-text">WebScoket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YGM</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Super fish
</div>


        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  




  
      <script type="text/javascript">
        (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
        })(document, 'script');
    </script>
  


  
  

  

  

  

  


  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":160,"height":160,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>

<script type="text/javascript">
  if (window.screen.width > 750) {
    var canvasScript = document.createElement("script");
    canvasScript.setAttribute("type", "text/javascript");
    canvasScript.setAttribute("src", "/lib/canvas-nest/canvas-nest.min.js");
    canvasScript.setAttribute("color", '255,0,204');
    canvasScript.setAttribute("opacity", '0.5');
    canvasScript.setAttribute("zIndex", '-2');
    canvasScript.setAttribute("count", '40');
    document.body.appendChild(canvasScript);
  }
</script>

</html>
