<!doctype html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="前言 重塑JavaScript的第四篇，讲述的是在JavaScript中，原型系统的概念，以及JS通过其语言特性实现的基于类的面向对象。">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript重塑(4)——JS的原型与模拟类">
<meta property="og:url" content="https://www.yuguomin.com/2019/10/09/JavaScript-restore-4/index.html">
<meta property="og:site_name" content="SuperFish&#39;s Blog">
<meta property="og:description" content="前言 重塑JavaScript的第四篇，讲述的是在JavaScript中，原型系统的概念，以及JS通过其语言特性实现的基于类的面向对象。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-02-17T09:11:15.866Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript重塑(4)——JS的原型与模拟类">
<meta name="twitter:description" content="前言 重塑JavaScript的第四篇，讲述的是在JavaScript中，原型系统的概念，以及JS通过其语言特性实现的基于类的面向对象。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.yuguomin.com/2019/10/09/JavaScript-restore-4/">





<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #3385ff; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #3385ff, 0 0 5px #3385ff; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #3385ff;    /*上边框颜色*/
        border-left-color: #3385ff;    /*左边框颜色*/
    }
</style>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
  <title> JavaScript重塑(4)——JS的原型与模拟类 | SuperFish's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <a href="https://github.com/yuguomin/blog-web"><img style="position:absolute;top:0;left:0;border:0;z-index:1;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SuperFish's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">day day up~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.yuguomin.com/2019/10/09/JavaScript-restore-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YGM">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://cdn.yuguomin.com/images/common/test-smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SuperFish's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript重塑(4)——JS的原型与模拟类
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T23:21:19+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript-Restore/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript Restore</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          

          
          
          <span class="post-time">
            &nbsp; | &nbsp;
                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-o"></i>
                  </span>
                  <span class="post-meta-item-text">字数统计:</span>
                  <span class="post-count">4.9k(字)</span>
                </span>
            
              <span class="post-time">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">阅读时长:</span>
            <span class="post-count">19(分)</span>
            
          </span>

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">
            Visitors<span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>重塑JavaScript的第四篇，讲述的是在JavaScript中，原型系统的概念，以及JS通过其语言特性实现的基于类的面向对象。</li>
</ul>
<a id="more"></a>
<h1 id="基于类和基于原型"><a href="#基于类和基于原型" class="headerlink" title="基于类和基于原型"></a>基于类和基于原型</h1><p>前面一篇，讲到了JavaScript是基于对象，或者说基于原型的语言，利用原型来描述对象。其本质也是一种面向对象语言，只是实现的方式与其他主流的实现方式不同，因而产生了误会。<br>主流的方式，是通过“类”的形式描述对象，也为此产生了许多的模拟面向对象的方式，就是模拟这种基于类的方式。实际上，基于原型的面向对象也是一种很优秀的方式。</p>
<p>说到基于类和基于原型，就需要重新思考一下类和原型的定义与区别。</p>
<ul>
<li>类，是一些对象的一组特定属性的定义，它是抽象的事物，“基于类”的编程提倡使用一个关注分类和类之间关系开发模型。<strong>先有类，然后去实例化一个对象</strong>。类与类之间有继承、组合等关系。</li>
<li>原型，原始形态。本质就是对象，对象可以在创建和运行时添加属性，然后作为其他对象的模版（原型），共享这些属性。这种“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，<strong>划分到最近的使用方式相似的原型对象</strong>，而不是将它们分成类。</li>
</ul>
<p>基于原型的面向对象系统通过“复制”的方式来创建新对象。就是先有了某一种模版对象用作原型，再来创建新对象。在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，这恰恰正是JavaScript对象模型所拥有的特性。</p>
<p>原型系统的“复制操作”有两种实现思路：</p>
<ul>
<li>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</li>
<li>另一个是切实地复制对象，从此两个对象再无关联。</li>
</ul>
<p>基于这两种思路，基于原型产生了两种流派，JavaScript是前者。</p>
<h1 id="JS的原型系统"><a href="#JS的原型系统" class="headerlink" title="JS的原型系统"></a>JS的原型系统</h1><p>JS的原型系统可以简单的概括：</p>
<ul>
<li>每个对象都有私有字段<code>[[prototype]]</code>，就是对象的原型；</li>
<li>当获取一个对象的属性时，如果本身没有这个属性，会在它的原型上找，直到原型为空或者找到为止。<br>这两个特点构成了原型链。</li>
</ul>
<p>这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为：</p>
<ul>
<li><code>Object.create</code>根据指定的原型创建新对象，原型可以是 null；</li>
<li><code>Object.getPrototypeOf</code>获得一个对象的原型；</li>
<li><code>Object.setPrototypeOf</code>设置一个对象的原型。</li>
</ul>
<p>利用这三个方法，完全可以抛开类的思维，利用原型实现抽象和复用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'meow~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  jump() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'jump'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tiger = <span class="built_in">Object</span>.create(cat, &#123; </span><br><span class="line">    say() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'roar'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> anotherCat = <span class="built_in">Object</span>.create(cat);</span><br><span class="line">anotherCat.say(); <span class="comment">// 'meow~'</span></span><br><span class="line"><span class="keyword">var</span> anoterTiger = <span class="built_in">Object</span>.create(tiger);</span><br><span class="line">anoterTiger.say(); <span class="comment">// 'roar'</span></span><br></pre></td></tr></table></figure>

<p>在这段代码当中，先创建了一个“猫”对象，然后以这个“猫”对象为原型创造了“虎”对象，然后以这两种对象为原型分别创造了实例对象“一只猫”和“一只虎”。<br>这种操作原型的风格看起来也和简便，<code>Object.create</code>既可以为新创建的对象指定原型，又可以为自己添加属性（第二个参数），通过原型链规则来覆盖原型的属性。</p>
<p>这种方法可以看到一个特点，我们创建的所有对象都是可以用来作为原型的，它和我们模拟类的方式有一个很大的区别在于<code>constructor</code>这个东西。就是我们不需要关心这个对象是什么东西，我们只需要关心它能做什么，有什么东西和它相似，借过来用用，不一样的改掉。</p>
<p>在更早的版本中，我们只能通过 Java 风格的类接口来操纵原型运行，利用<code>new</code>和<code>prototype</code>来完成工作。</p>
<h1 id="JS模拟基于类的要素"><a href="#JS模拟基于类的要素" class="headerlink" title="JS模拟基于类的要素"></a>JS模拟基于类的要素</h1><p>刚才提到了一个词，<code>constructor</code>，这是什么呢？<br>它是构造函数，也就是一个函数，可以作来当模版，创造一个实例对象。我们通过<code>new</code>来具体了解它，我们常说<code>new</code>一个对象出来，比如代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br></pre></td></tr></table></figure>

<p><code>new</code>到底做了什么，我们先用一段JS代码来模拟一下new运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;; <span class="comment">// 最终返回的对象</span></span><br><span class="line">  <span class="keyword">if</span> (fn.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    result.__proto__ = fn.prototype; <span class="comment">// 让返回的对象的__proto__指向构造函数的prototype</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ret = fn.apply(result, [...arguments].slice(<span class="number">1</span>)); <span class="comment">// 修改this指向，传入参数拿到执行结果</span></span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">'object'</span>, <span class="string">'function'</span>].includes(<span class="keyword">typeof</span> ret) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 结果为对象类型则返回该结果，不是返回之前创造的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个方法看<code>new</code>原理：</p>
<ol>
<li>new运算符接受一个构造函数和一组调用参数；</li>
<li>首先会在内存中开辟一块空间，创造一个空对象；</li>
<li>将对象的<code>__proto__</code>指向构造函数的原型；</li>
<li>将构造函数中的<code>this</code>指向该对象，并传入参数执行；</li>
<li>如果执行结果是对象类型，则返回该结果，否则返回上面获取的对象。</li>
</ol>
<p>我们再来看一看<code>new</code>的使用效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Cat'</span>,</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"meow~"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'kaka'</span>);</span><br><span class="line">cat1.showName(); <span class="comment">// 'kaka'</span></span><br><span class="line">cat1.say(); <span class="comment">// 'meow~'</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1 <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Cat.prototype.isPrototypeOf(cat1)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.constructor.name); <span class="comment">// 'Cat'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(cat1)); <span class="comment">// '[object Cat]'</span></span><br></pre></td></tr></table></figure>

<p>结合原理与使用，<code>new</code>做的事情实际上是在试图让函数对象在语法上跟类比较相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。在没有<code>Object.create</code>和<code>Object.setPrototypeOf</code>方法的时候，<code>new</code>运算符可以说是唯一一个直接指定实例<code>[[prototype]]</code>的方法，哪怕是前面代码用到的<code>__proto__</code>在很多环境下不支持。</p>
<p>回到刚才的问题，<code>constructor</code>就是代码中的<code>Cat</code>构造<strong>函数</strong>，我们甚至可以把它理解为类，通过下面<code>instanceof</code>和<code>isPrototypeOf</code>和<code>constructor.name</code>可以获取到这种对应关系；通过我们在构造函数中修改<code>Symbol.toStringTag</code>属性，让其输出的“类名”也为<code>Cat</code>。</p>
<p>通过<code>new</code>配合<code>constructor</code>和<code>prototype</code>结合模拟了类的效果，其实在 JavaScript 推出之时，管理层就要求它去模仿 Java。因此，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”。</p>
<h1 id="JS模拟基于类的面向对象实践"><a href="#JS模拟基于类的面向对象实践" class="headerlink" title="JS模拟基于类的面向对象实践"></a>JS模拟基于类的面向对象实践</h1><p>面向对象有三大特性，封装、继承和多态。在ES6之前，还没有<code>class</code>的概念，都是通过<code>new</code>和<code>constructor</code>加上<code>prototype</code>的模拟。这里使用JavaScript的语法特性和这三个关键字来实现面向对象三大特性。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>类在JS中可以说就是构造函数<code>constructor</code>，它有自己的属性和方法，它的原型上也有属性和方法，外部以<code>new</code>调用构造函数得以创建实例对象。组成这个<strong>类</strong>的过程就是封装。</p>
<p id="div-border-left-green">
封装的概念：把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。
</p><p>
常用的一些封装方式：

<ul>
<li>通过构造函数内部为实例添加属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.showName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</p><p>通过这种方式给实例添加属性，在每一次使用<code>new</code>来创建的时候，为<code>this</code>添加的内容都会再创建一份，造成了内存浪费。</p>
<ul>
<li>通过构造函数的实例<code>prototype</code>来为实例共享属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过这种方式为实例共享属性解决了内存浪费的问题，所有实例通过原型链的特点最终使用的都是一个属性，但这种方式有一个问题就是，<strong>如果有实例对其原型上的属性进行修改，可能会影响到其他实例，多发生在对象类型的修改上</strong>。</p>
<ul>
<li><p>为构造函数添加静态方法，实例无法共享，但可以通过构造函数访问到该属性，通常用在一些类相关的 helper，如<code>Array.from</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Cat.showName = <span class="function"><span class="keyword">function</span>(<span class="params">cat</span>) </span>&#123; <span class="built_in">console</span>.log(cat.name); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用JS构造函数作用域的特点为类添加内部的方法，其他方式均不可调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loveFood = <span class="string">'fish'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.eatFood = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`eat <span class="subst">$&#123;loveFood&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这种方式可以添加类中独立作用域的属性，可以通过共享的属性去让实例获取到。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p id="div-border-left-green">
继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。
</p><p>
继承实际上就是用之前的共享属性的方式来实现的。

</p><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>类式继承，就是通过在父类的原型上添加属性，然后将父类的实例作为子类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>];</span><br><span class="line">  <span class="keyword">this</span>.superValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'superValue is true'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.changeId = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    id = num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型上的方法</span></span><br><span class="line">SuperClass.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.superValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'subValue is true'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类原型指向父类实例（重点），并为子类原型添加方法</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subValue()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubClass();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line">sub1.getSuperValue(); <span class="comment">// 'superValue is true' 1</span></span><br><span class="line">sub2.getSubValue(); <span class="comment">// 'subValue is true'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.id); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line"></span><br><span class="line">sub1.books.push(<span class="string">'CSS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript', 'CSS']</span></span><br><span class="line"></span><br><span class="line">sub2.changeId(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.getSuperValue()); <span class="comment">// 'superValue is true' 2</span></span><br></pre></td></tr></table></figure>

<p>这种继承方式，是通过原型挂载属性，共享给实例，因此如果子类的实例修改了原型上的属性，可能会造成对其他实例的影响。并且这种方式没办法在不影响其他实例的情况下为父类构造函数传递参数。</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>为了解决类式继承出现了构造函数式继承，它是通过改变<code>this</code>指向，把父类构造函数中的属性挂载到子类实例上。因为是通过<code>call</code>方法在每次子类调用的时候执行一次，一次是相对独立的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>];</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类上的方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类 通过call方法调用父类改变指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubClass(<span class="number">1</span>, <span class="string">'book'</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubClass(<span class="number">2</span>, <span class="string">'library'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// 'book'</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// 'library'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line">sub1.books.push(<span class="string">'CSS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.books); <span class="comment">// ['JavaScript', 'CSS']</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line"></span><br><span class="line">sub1.showBooks(); <span class="comment">// TypeError: sub1.showBooks is not a function;</span></span><br></pre></td></tr></table></figure>

<p>这种方式成功区分开了实例间共享同一地址造成的修改影响问题，但是相应的，内存也会浪费。并且无法共享到父类原型上的方法，这里看起来可以通过指定子类的原型为父类的原型来进行共享，但是如果想为子类原型再添加属性也会影响到父类。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承就是通过结合类式继承和构造函数式继承来解决构造函数式继承丢失的父类原型共享问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>];</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类上的方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类 通过call方法调用父类改变指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型指向父类实例</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubClass(<span class="number">1</span>, <span class="string">'book'</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubClass(<span class="number">2</span>, <span class="string">'library'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// 'book'</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// 'library'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line">sub1.books.push(<span class="string">'CSS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.books); <span class="comment">// ['JavaScript', 'CSS']</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line"></span><br><span class="line">sub1.showBooks(); <span class="comment">// ['JavaScript', 'CSS']</span></span><br></pre></td></tr></table></figure>

<p>组合继承的问题是父类构造函数会调用两次，并且子类的原型上多了一套父类的构造函数内挂载的属性。</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>寄生组合继承，就是通过构造函数式继承来继承父类构造函数将要挂载给实例的属性，通过创建父类原型的实例副本，然后将子类指向它即可。但需要注意的是这个需要更正副本的<code>constructor</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  fn.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prot = inheritObject(superClass.prototype);</span><br><span class="line">  prot.constructor = subClass;</span><br><span class="line">  subClass.prototype = prot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>];</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类上的方法</span></span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, id);</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubClass, SuperClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubClass(<span class="number">1</span>, <span class="string">'book'</span>);</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> SubClass(<span class="number">2</span>, <span class="string">'library'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub1.name); <span class="comment">// 'book'</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.name); <span class="comment">// 'library'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br><span class="line">sub1.books.push(<span class="string">'CSS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.books); <span class="comment">// ['JavaScript', 'CSS']</span></span><br><span class="line"><span class="built_in">console</span>.log(sub2.books); <span class="comment">// ['JavaScript']</span></span><br></pre></td></tr></table></figure>

<p>继承这一块的代码demo已经上传github，<a href="https://github.com/yuguomin/study-demo/tree/master/class-inherit" target="_blank" rel="noopener">点击查看</a></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p id="div-border-left-green">
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。
</p><p>
多态的思想是将“做什么”和“谁去做”以及“怎样去做”分离开。
比如：本人家里养了一只鸡，一只鸭。当主人向他们发出‘叫’的命令时。鸭子会嘎嘎的叫，而鸡会咯咯的叫。转化成代码形式如下：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'嘎嘎嘎'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Chiken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Chiken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'咯咯咯'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeSound(<span class="keyword">new</span> Chicken());</span><br><span class="line">makeSound(<span class="keyword">new</span> Duck());</span><br></pre></td></tr></table></figure>

</p><p>做什么是<code>makeSound</code>，谁去做，就是不同的实例<code>new Chicken()</code>和<code>new Duck()</code>，怎样去做，就是各自原型上的方法<code>prototype.sound</code>。<br>事情是一件，执行者不同，执行方式也不同，清除了他们之间的耦合。</p>
<p>总的来说，JavaScript因为其灵活的原型链和动态机制，所以它的写法很多，这里重要的是去理解模拟类的思想，和原型链的关系。</p>
<h1 id="ES6的class"><a href="#ES6的class" class="headerlink" title="ES6的class"></a>ES6的class</h1><p>ES6引入了类<code>Class</code>的概念，作为对象的模版。通过<code>class</code>关键字来定义类，写一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' makes a noise.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, like) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.like = like;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating <span class="subst">$&#123;<span class="keyword">this</span>.like&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> Dog(<span class="string">'kaka'</span>, <span class="string">'ham'</span>);</span><br><span class="line">myDog.speak(); <span class="comment">// 'kaka makes a noise.'</span></span><br><span class="line">myDog.eat(); <span class="comment">// kaka is eating ham‘</span></span><br><span class="line"><span class="built_in">console</span>.dir(myDog);</span><br></pre></td></tr></table></figure>

<p>通过这个例子最终打印出<code>myDog</code>实例，可以发现：</p>
<ul>
<li>子类和父类中的<code>constructor</code>通过<code>this</code>添加给实例的属性都直接添加在了最终的实例上，并且能解决每个子类独立为父类传参；</li>
<li>子类中定义的方法最终挂载在了实例的原型上，父类中定义的方法挂载在了实例的原型的原型上；</li>
</ul>
<p>上面实现了<strong>在原型上方法的继承</strong>与<strong>实例本身挂载属性和方法</strong>，那么如何定义原型上属性的继承，以及类的静态方法？看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, like) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.like = like;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> coat() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'white'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating <span class="subst">$&#123;<span class="keyword">this</span>.like&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> jump(dog) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;dog.name&#125;</span> is jumping`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> Dog(<span class="string">'kaka'</span>, <span class="string">'ham'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myDog.coat); <span class="comment">// 'white'</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog); <span class="comment">// Dog &#123; name: 'kaka', like: 'ham' &#125;</span></span><br><span class="line">Dog.jump(myDog); <span class="comment">// 'kaka is jumping'</span></span><br></pre></td></tr></table></figure>

<p>上面实现了静态方法<code>jump</code>和在原型上的属性<code>coat</code>，可以总结下：</p>
<ul>
<li>添加原型的属性只能通过<code>getter</code>进行实现，在实现后会发现实例上也会有一个相同属性，但是若修改实例的原型指向，这个实例上的该属性也会消失。</li>
<li>静态属性通过<code>static</code>为前缀，最终属性会挂载在这个类上，可以通过这个类直接调用。</li>
</ul>
<p>现在完成了实例上的属性方法，原型上的属性方法，以及类的静态方法，还缺少一个类的私有属性，也就是在类中可以调用，其他地方均不可调用；这个问题现在要想很优雅的实现方式还在提案中；这里的方法使用 ES6 的<code>WeakMap</code>和闭包来实现，当然也可以通过<code>Symbol</code>加上<code>export</code>的模块隔离来完成。ES5也可以通过闭包加上标识id来实现，但是存在很多隐患与弊端，这里就不讲了。</p>
<p>首先使用<code>Symbol</code>加上<code>export</code>的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.js 文件</span></span><br><span class="line"><span class="keyword">const</span> _like = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// 使用ES6模块语法导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>[_like] = <span class="string">'ham'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating <span class="subst">$&#123;<span class="keyword">this</span>[_like]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 导入Dog类</span></span><br><span class="line"><span class="keyword">import</span> &#123; Dog &#125; <span class="keyword">from</span> <span class="string">'./Dog.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> Dog(<span class="string">'kaka'</span>);</span><br><span class="line">myDog.eat(); <span class="comment">// 'kaka is eating ham'</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog); <span class="comment">// Dog &#123; name: 'kaka', [Symbol()]: 'ham' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog[<span class="built_in">Symbol</span>()]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog._like); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用该方法是通过模块隔离，只导出类，而将其私有属性<code>key</code>设置为唯一的<code>Symbol</code>类型，这样在其他模块使用的时候就没有办法直接拿到该属性了，实际上使用<code>Object.getOwnPropertySymbols</code>还是可以获取到该属性。</p>
<p>通过<code>Symbol</code>的方式我们可以得到一个启发，保证唯一就好，并且让类的外部获取不到。那么对于每一个实例有什么是唯一的呢？内存地址？JS无法直接获取，那么就对象本身吧！这个时候<code>WeakMap</code>就出来了，<code>WeakMap</code>创造的对象<code>key</code>值必须是<code>Object</code>类型，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Dog = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateProp = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, like) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      privateProp.set(<span class="keyword">this</span>, &#123; like &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is eating <span class="subst">$&#123;privateProp.get(<span class="keyword">this</span>).like&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Dog;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myDog = <span class="keyword">new</span> Dog(<span class="string">'kaka'</span>, <span class="string">'ham'</span>);</span><br><span class="line">myDog.eat(); <span class="comment">// 'kaka is eating ham'</span></span><br></pre></td></tr></table></figure>

<p>通过<code>WeakMap</code>来创建的对象还有一个特点，它的<code>key</code>是“弱引用”，当没有其它引用指向该key对象时，该对象即可被垃圾回收，WeakMap不会阻止回收。这会优化内存泄漏问题。</p>
<p>通过ES6的<code>class</code>关键字已经能够很优雅的实现类了，但是我们仍然需要明白它的原理，它也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，从函数的方式到class的方式，理解运行时的原型系统都是很有必要的一件事。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上一篇从对象的模型到基于对象的理念，到本篇理解原型链系统特点，和利用这种特点去实现基于类的面向对象实现，再到ES6的基于类实践。更深刻理解在语言设计上带来的优势与弊端。</p>
<p>参考相关文章链接：<br><a href="[点击查看](https://github.com/yuguomin/study-demo/tree/master/class-inherit)">继承代码实现demo</a><br><a href="https://time.geekbang.org/column/article/77749" target="_blank" rel="noopener">重学前端-winter</a></p>

      
    </div>
    <div>
      
        <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        

      
    </div>

    <div>
      
        

      
    </div>
  <div>
        <p id="div-border-left-red">
      <b>本文基于<a target="_blank" title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href="http://creativecommons.org/licenses/by-sa/4.0/"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br>
        <span>
        <b>本文地址: </b><a href="/2019/10/09/JavaScript-restore-4/" title="JavaScript重塑(4)——JS的原型与模拟类">https://www.yuguomin.com/2019/10/09/JavaScript-restore-4/</a><br><b>转载请注明出处, 谢谢！</b>
        </span>
        </p>
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"> JavaScript</i></a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/02/JavaScript-restore-3/" rel="next" title="JavaScript重塑(3)——JS的对象模型与基于对象">
                <i class="fa fa-chevron-left"></i> JavaScript重塑(3)——JS的对象模型与基于对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/15/JavaScript-restore-5/" rel="prev" title="JavaScript重塑(5)——JS对象的分类">
                JavaScript重塑(5)——JS对象的分类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到: </div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div>
<div class="-mob-share-ui" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-qzone"><p>QQ空间</p></li>
        <li class="-mob-share-qq"><p>QQ好友</p></li>
        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
        <li class="-mob-share-renren"><p>人人网</p></li>
        <li class="-mob-share-kaixin"><p>开心网</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
        <li class="-mob-share-mingdao"><p>明道</p></li>
        <li class="-mob-share-pengyou"><p>朋友网</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=2bee37e5c8594"></script>
<!--MOB SHARE END-->
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTk4MC8yMjQ5MQ=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="https://cdn.yuguomin.com/images/common/test-smile.jpg" alt="YGM">
          <p class="site-author-name" itemprop="name">YGM</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        
<div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("08/03/2019 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于类和基于原型"><span class="nav-number">2.</span> <span class="nav-text">基于类和基于原型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS的原型系统"><span class="nav-number">3.</span> <span class="nav-text">JS的原型系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS模拟基于类的要素"><span class="nav-number">4.</span> <span class="nav-text">JS模拟基于类的要素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS模拟基于类的面向对象实践"><span class="nav-number">5.</span> <span class="nav-text">JS模拟基于类的面向对象实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">5.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">5.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类式继承"><span class="nav-number">5.2.1.</span> <span class="nav-text">类式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数继承"><span class="nav-number">5.2.2.</span> <span class="nav-text">构造函数继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合继承"><span class="nav-number">5.2.3.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生组合继承"><span class="nav-number">5.2.4.</span> <span class="nav-text">寄生组合继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">5.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6的class"><span class="nav-number">6.</span> <span class="nav-text">ES6的class</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YGM</span>
</div>


<div class="powered-by">
   个人专属
</div>

<div class="theme-info">
  博客 - Super fish
</div>


        

<div class="busuanzi-count">

  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  




  
      <script type="text/javascript">
        (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
        })(document, 'script');
    </script>
  


  
  

  

  

  

  


  

  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":160,"height":160,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>

</html>
